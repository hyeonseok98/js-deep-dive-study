# [11장] 원시 값과 객체의 비교

### 원시 타입과 객체 타입의 차이점?

> **원시 값** 은 변경 불가능 값<br /> > **객체** 는 변경 가능한 값

> **원시 값** 을 변수에 할당하면 변수(확보된 메모리 공간)에는 실제 값이 저장<br /> > **객체** 는 참조 값이 저장

> **원시 값** 을 갖는 변수를 다른 변수에 할당하면 원본의 값이 복사되어 전달(값에 의한 전달)<br /> > **객체** 는 원본의 참조값이 복사됨(참조에 의한 전달)

## 원시 값

### 1️⃣ 변경 불가능한 값

- 원시 타입(primitive type)의 값은 읽기 전용 값으로 변경 불가능한 값
- 변경 불가능 한 것은 '원시 값'이고 변수 값은 변경(메모리 주소를 바꿔서 재할당) 가능
- **불변성**, 엄밀히 따지면 메모리 주소 '변경'이 아닌 메모리 공간 삭제 후 새로운 곳에 할당..!🟢
- 상수는 재할당이 금지된 변수

```jsx
const o = {};

// const로 선언한 변수에 할당한 원시값(상수)은 변경 불가
// BUT, 변수에 할당한 객체는 변경 가능
o.a = 1;
console.log(o); // {a: 1}
```

### 2️⃣ 문자열과 불변성

- 문자열은 원시 타입으로 변경 불가능
- 문자열은 유사 배열 객체 & 이터러블. 즉, 배열처럼 각 문자에 접근 가능!

#### 🤔 유사 배열 객체란?🟢

- 인덱스로 프로퍼티 값에 접근 가능
- length 프로퍼티를 갖는 객체
- 즉, 문자열은 인덱스로 프로퍼티에 접근하고, length 프로퍼티를 갖고, for문으로 순회 가능한 유사 배열 객체!

```jsx
let str = "string";

// 문자열은 유사 배열이므로 인덱스를 사용해 각 문자에 접근 가능
console.log(str[0]); // s

// length 프로퍼티
console.log(str.length); // 6

// 함수 객체(메서드)
console.log(str.toUpperCase()); // STRING
```

❗️ 하지만 문자열은 원시 값이므로 변경할 수는 없고 변수에 새로운 문자열 재할당은 가능한 것🟢

### 3️⃣ 값에 의한 전달🟢

변수에 원시 값을 갖는 '변수'를 할당하면 할당 받는 변수에는 할당되는 변수의 '원시 값'만 복사되어 전달되는 것

```jsx
var score = 80;
var copy = score;

console.log(score, copy); // 80 80
console.log(score === copy); // true

score = 100;

console.log(score, copy); // 100 80
console.log(score === copy); // false
```

두 변수는 결국 다른 메모리 공간에 저장된 별개의 값이다.

**왜 일까? 🤔**

> - 변수의 '값'이 복사되었다는 것이지, 변수의 '메모리 주소'가 복사되었다는 것은 아님!
> - 원시 값이 가진 불변성 때문인데, 이는 변수에 할당, 재할당 원리를 알면 이해할 수 있음

**그래서 변수에 할당한 값이 어떤데?**

> - 엄밀히는 변수 같은 식별자는 값이 아니라 메모리 주소를 저장하고 있음
> - 그래서 '값에 의한 전달'이 조금 어색한 말일 수 있으니, '메모리 주소의 전달'이 더 적합하겠고..!
> - 결론, 원시 값을 변수에 할당할 때 값 자의 복사로 복사 이후에는 독립된 값이며, 참조의 복사가 아니라는 것

**변수할당 시점에 따른 식별자 표현식 예시** (5장 표현식과 문)

```jsx
var copy = score; // 80
```

ECMAScript 사양에도 명확히 정의된 것이 없기 때문에 두 가지 평가 방식으로 접근해 볼 수 있다.

1. 새로운 80 생성하고 메모리 주소 전달 (할당 시점에 두 변수가 기억하는 메모리 주소 다름)
2. score의 변수값 80의 메모리 주소를 그대로 전달 (할당 시점에 두 변수가 기억하는 메모리 주소 같음)

## 객체

- 객체는 참조 타입의 값. 즉, 변경 가능한 값
- 객체를 할당한 변수 참조 시, 메모리에 저장되어 있는 참조 값(값이 아닌 메모리 공간의 주소)을 통해 접근
- 재할당 없이 프로퍼티 직접 변경(추가, 갱신, 삭제) 가능
- ❗️ 여러 식별자가 하나의 객체를 공유하는 단점 : 객체의 크기를 알 수 없고 프로퍼티가 객체일 수 있으므로 메모리 효율을 위해 원시 값처럼 값이 복사되어 새로 생성되지 않고 참조 하도록 설계됨

### ℹ️ 얕은 복사와 깊은 복사

프로퍼티 값으로 갖는 객체의 복사 (원본과 다른 복사본)

- 얕은 복사: 한 단계까지만 복사. 참조 값을 복사함
- 깊은 복사: 객체에 중첩되어 있는 객체까지 모두 복사. 원시 값처럼 완전한 복사본

```jsx
const o = { x: { y: 1 } };

// 얕은 복사
const c1 = { ...o };
console.log(c1 === o); // false
console.log(c1.x === o.x); // true

// lodash의 cloneDeep을 사용한 깊은 복사
// "npm install lodash"로 lodash를 설치한 후, Node.js 환경에서 실행
const _ = require("lodash");
// 깊은 복사
const c2 = _.cloneDeep(o);
console.log(c2 === o); // false
console.log(c2.x === o.x); // false
```

- 얕은 복사: 객체를 할당한 변수를 다른 변수에 할당하는 것
- 깊은 복사: 원시 값을 할당한 변수를 다른 변수에 할당하는 것

```jsx
const v = 1;

// "깊은 복사"라고 부르기도 한다.
const c1 = v;
console.log(c1 === v); // true

const o = { x: 1 };

// "얕은 복사"라고 부르기도 한다.
const c2 = o;
console.log(c2 === o); // true
```

### 참조에 의한 전달

**객체를 가리키는 변수를 다른 변수에 할당(복사)하면 원본의 참조 값이 복사되어 전달되는 것**

```jsx
let person = {
  name: "Lee",
};

// 참조값을 복사(얕은 복사). copy와 person은 동일한 참조값을 갖는다.
let copy = person;

// copy와 person은 동일한 객체를 참조한다.
console.log(copy === person); // true

// copy를 통해 객체를 변경한다.
copy.name = "Kim";

// person을 통해 객체를 변경한다.
person.address = "Seoul";

// copy와 person은 동일한 객체를 가리킨다.
// 따라서 어느 한쪽에서 객체를 변경하면 서로 영향을 주고 받는다.
console.log(person); // {name: "Kim", address: "Seoul"}
console.log(copy); // {name: "Kim", address: "Seoul"}
```

🤔 여러 개의 식별자가 하나의 객체를 공유한다?<br>
공유에 의한 전달이 되기 때문에 값이 바뀌는 대로 같이 바뀌어 버리는 점을 유의하자!

```jsx
let person1 = {
  name: "Lee",
};

let person2 = {
  name: "Lee",
};

console.log(person1 === person2); // false, 객체 내용은 같지만 저장된 메모리 위치가 다르기 때문
console.log(person1.name === person2.name); // true, 객체의 프로퍼티로 접근했기 때문에 원시 값은 같다고 평가
```
