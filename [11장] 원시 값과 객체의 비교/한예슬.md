# 11장 원시 값과 객체의 비교

- 변수 : 하나의 값을 저장하기 위해 확보한 `메모리 공간` 자체 / 그 메모리 공간을 식별하기 위해 붙인 이름.<br>
  -> 즉, 식별자는 메모리 주소에 붙인 이름이다!
- 값 : `변수에 저장된 데이터`로서 표현식이 평가되어 생성된 결과.<br>
  -> 변경 불가능하다는 것은 변수가 아니라 값에 대한 진술이다!

## ✔️ 원시 값과 객체타입의 다른 3가지 측면

### 1. 변경 가능 vs 불가능

- 원시값은 `변경 불가능한 값`이다.
- 객체(참조) 타입의 값은 `변경 가능한 값`이다.

### 2. 저장되는 데이터

- `원시값`을 변수에 할당하면 변수(확보된 메모리 공간)에는 `실제 값`이 저장된다.
- `객체`를 변수에 할당하면 변수에는 `참조 값`이 저장된다.

### 3. 다른 변수에 할당시

- ### `값에 의한 전달`
  - 원시값을 갖는 변수를 다른 변수에 할당하면 `원본의 원시 값`이 복사되어 전달된다.
  - 값에 의한 전달도 사실은 값을 전달하는 것이 아니라 메모리 주소를 전달한다. <br>단, 전달된 메모리 주소를 통해 메모리 공간에 접근하면 값을 참조할 수 있다.
  - 두 변수의 원시값은 서로 다른 메모리 공간에 저장된 별개의 값이 되어 어느 한쪽에서 재할당을 통해 값을 변경하더라도 서로 간섭할 수 없다.
    <br>
- ### `참조에 의한 전달`

  - 객체를 가리키는 변수를 다른 변수에 할당하면 `원본의 참조 값`이 복사되어 전달된다.

  ***

## ✔️ 원시 값

- 원시 값을 할당한 변수에 새로운 원시 값을 `재할당`하면 메모리 공간에 저장되어 있는 재할당 이전의 원시 값을 변경하는 것이 아니라 `새로운 메모리 공간을 확보`하고 `재할당한 원시 값을 저장`한 후, `변수는 새롭게 재할당한 원시 값을 가리킨다.` <br>
  -> 변수가 참조하던 메모리 공간의 주소가 바뀐다.
  -> _불변성_

- 불변성을 갖는 원시 값을 할당한 변수는 재할당 이외에 변수 값을 변경할 수 있는 방법이 없다.

<br>

### 💡 유사배열 객체 (문자열)

> 마치 배열처럼 인덱스로 프로퍼티 값에 접근할 수 있고 length 프로퍼티를 갖는 객체를 말한다. 문자열은 마치 배열처럼 인덱스를 통해 각 문자에 접근할 수 있으며, length 프로퍼티를 갖기 때문에 유사배열 객체이고 for 문으로 순회할 수도 있다.
>
> 원시값을 객체처럼 사용하면 원시값을 감싸는 래퍼객체로 자동 변환된다.

<br>

## ✔️ 객체

- 객체는 변경 가능한 값이다. 객체를 할당한 변수는 재할당 없이 객체를 직접 변경할 수 있다.<br>
  -> 재할당 없이 프로퍼티를 동적으로 추가할 수 있고, 프로퍼티 값을 갱신할 수도 있으며, 프로퍼티 자체를 삭제할 수도 있다.

- 여러개의 식별자가 하나의 객체를 공유할 수 있다.
  - 원본 또는 사본 중 어느 한쪽에서 객체를 변경 (변수에 새로운 객체를 재할당하는 것이 아니라, `객체의 프로퍼티 값을 변경하거나 프로퍼티를 추가, 삭제`) 하면 `서로 영향을 주고받는다.`

<br>

```jsx
var person = {
  name: "Lee",
};

// 참조 값을 복사 (얕은복사). copy와 person은 동일한 참조 값을 갖는다.
var copy = person;

// copy와 person은 동일한 객체를 참조한다.
console.log(copy === person); // true

// copy를 통해 객체를 변경한다.
copy.name = "Kim";

// person을 통해 객체를 변경한다.
person.address = "Seoul";

// copy와 person은 동일한 객체를 가리킨다.
// 따라서 어느 한쪽에서 객체를 변경하면 서로 영향을 주고받는다.
console.log(person); // {name: "Kim", address: "Seoul"}
console.log(copy); // {name: "Kim", address: "Seoul"}
```

<br>

### 💡 얕은 복사와 깊은 복사

> 객체를 프로퍼티 값으로 갖는 객체의 경우 `얕은 복사`는 `한 단계까지만 복사하는 것`을 말하고 `깊은 복사`는 `객체에 중첩되어있는 객체까지 모두 복사하는 것`을 말한다.
>
> 얕은 복사와 깊은 복사로 생성된 객체는 원본과는 다른 객체다. 즉, 원본과 복사본은 참조값이 다른 별개의 객체다.
>
> 하지만 얕은 복사는 객체에 중첩되어 있는 객체의 경우 참조 값을 복사하고, 깊은 복사는 객체에 중첩되어 있는 객체까지 모두 복사해서 원시 값처럼 완전한 복사본을 만든다는 차이가 있다.
>
> 원시값을 할당한 변수를 다른변수에 할당하는 것 -> 깊은복사<br>
> 객체를 할당한 변수를 다른 변수에 할당하는 것 -> 얕은복사

### ✔️ex)

```jsx
var person1 = {
  name: "LEE",
};

var person1 = {
  name: "LEE",
};

console.log(person1 === person2); // false
console.log(person1.name === person2.name); // true
```

- person1 변수와 person2 변수가 가리키는 객체는 비록 내용은 같지만, 다른 메모리에 저장된 별개의 객체다. 즉, person1 과 person2 변수의 참조값은 전혀 다른 값이다. => false
- 하지만, 프로퍼티 값을 참조하는 person1.name , person2.name은 값으로 평가될 수 있는 표현식이다. 두 표현식 모두 원시값 "LEE" 로 평가된다. => true
