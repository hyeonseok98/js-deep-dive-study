# [11장] 원시 값과 객체의 비교

> 앞서, 원시 값은 변경 불가능한 값(immutable value)이며 객체는 변경 가능한 값(mutable value) 라고 했다. 이를 설명하기 위한 개념인 값에 의한 전달(pass by value)과 참조에 의한 전달(pass by reference)를 알아보자.

## 11.1 원시값

### 📝 변경 불가능한 값

원시값은 읽기 전용값으로, 변경이 불가능하다.

이 말을 보고, 이해가 되지 않을 것이다. 아래 예시를 보면서 이야기해보자.

```javascript
let variable1 = 1;

variable1 = "바꿨지롱";
```

'이렇게 하면 변경이 되는데 왜 안 된다는 거지?' 라고 생각했다면, 이 내용을 잘 알아야한다.

지금 우리가 선언한 "변수" `variable1` 은 원시값 `1`을 할당 받은 메모리 공간에다 부르기 쉬운 이름을 붙인 것이다.

그 다음에는 문자열을 대입했는데, 이때 원시값이 변경되는 것이 아니냐? 라고 생각하면 안된다.

`variabl1e` 에 `"바꿨지롱"` 을 새로 할당한 결과는 `1` 이 저장된 주소에서 `"바꿨지롱"`이 저장된 주소로 바뀔 뿐이다.

`1` 이 저장된 주소에는 아무런 변화가 없다. 단지 `variable1` 이 그 주소를 참조하지 않게 되었을 뿐.

그럼 이제 `const` 가 재할당을 금지한다는 것을 조금 더 잘 이해할 수 있다.

```javascript
const variable2 = 1;

variable2 = "바꿨지롱"; // 불가
```

위 예시에서, `const` 키워드로 선언한 `variable2` 는 초기화 이후 재할당이 불가능하다. 정확히는 참조하고 있는 공간의 주소를 바꾸지 못한다는 것이다.

이를 통해서 불변성을 지킬 수 있다. 이 불변성을 지키지 않는다면, 골치아픈 일이 많이 생길 수 있다.

한 변수를 여러 곳에서 재사용하고 있는 상황에서, 한 코드 블럭 내에서 원본을 바꿔버린다면 예기치 못한 오류가 생길 수 있기에 불변성을 유지하는 것이다.

### 📝 문자열과 불변성

앞서 자바스크립트의 데이터 타입에 대해 다룰 때, 숫자형(8 bytes)을 제외하고는 크기를 명확히 알 수 없다고 했다.

문자열의 경우, 1글자 당 2바이트 씩 차지하기에 그때 그때 차지하는 크기가 달라지게 된다.

하지만, 엄연히 문자열도 원시값이기 때문에 변경이 불가능하다.

```javascript
var str = "Hello";
str = "world";

str[0] = "s";

console.log(str); // "world"
```

`str` 변수 자체는 다른 값으로 할당이 가능한 상황이지만, 배열 처럼 접근해 한 글자만 바꾸려고 하니 변경되지 않는다.

사실 배열처럼 사용이 가능하다는 것은, 객체라고 할 수 있다.
이에 대해서는 추후 래퍼 객체를 다루며 알아보자.

### 📝 값에 의한 전달

```javascript
var score = 10;
var copy = score;

console.log(score); // 10
console.log(copy); // 10

console.log(score === copy); // true

score = 100;

console.log(score); // 100
console.log(copy); // 10

console.log(score === copy); // false
```

위 예시를 보면, `score` 를 복사한 뒤 값을 변경해도 `copy` 는 영향을 받지 않는다.

이때, `score` 의 값을 `copy` 에 복사하는 시점에 값만 복사해 다른 공간을 할당할 수도 있고(mdn 에서는 이렇게 설명한다고 함) 그렇지 않다면 같은 공간을 참조하다가 변경이 생기는 것을 감지하면 공간을 새로 할당할 수도 있다.

정확한 것은 브라우저 마다 다를 수도 있지만, 명확한 건 어떤 방식이든 원시값은 불변성을 잃지 않는다. 변경이 생길 때 새로운 공간을 할당하기만 하면 문제는 없으니!

## 11.2 객체

> 객체도 문자열 처럼 공간을 동적으로 확보하며, 개수의 제약도 존재하지 않는다.

자바스크립트 객체는 프로퍼티 키를 인덱스로 사용하는 해시 테이블처럼 생각할 수 있다.  
하지만, 일반적인 해시테이블 보다 개선된 방법을 사용해 성능을 개선했다고 한다.  
이와 관해서는 **히든 클래스** 방식을 참고하면 도움이 될 것이다.

### 📝 변경 가능한 값

객체는 변경이 가능한 값이라고 했다! 예시와 함께 살펴보자.

```javascript
var person = {
  name: "Lee",
};
```

`person` 변수를 통해 접근할 수 있는 메모리 공간에는 객체가 저장된 공간이다.  
이때, `person` 변수는 객체를 참조하고 있다고 표현하기도 한다.

`person` 에 저장한 객체의 프로퍼티는 얼마든지 수정이 가능하다.

```javascript
const person = {
  name: "Lee",
};

person.name = "Kim";
person.age = 20;
delete person.age;
```

이렇게 프로퍼티 수정/추가/삭제 모두 가능하다.
이 과정에서 실제로 원본 객체가 변경이 된다.  
'왜 원시값처럼 불변성을 보장하지 않느냐?' 라고 한다면 '객체가 얼마나 클 줄 알고??' 라고 답변할 수 있을 것이다.

실제 서비스에서 사용하는 정보들은 아주 크기가 크다. 이 큰 정보를 매번 복사해서 불변성을 보장하려면, 메모리가 남아나지 않을 것이다.

원본을 변경 하더라도 복사본을 따로 만들지 않기 때문에, 하나의 객체를 여러 변수가 참조하며 공유하는 형태가 되면 문제가 발생할 수 있다. (얕은 복사와 깊은 복사에 대해 알면 좋다.)

그리고, 위 예시처럼 객체의 경우 `const` 로 선언 하더라도 프로퍼티를 추가/변경 하는데 제한이 없다.

`const` 를 무시하는 것이 아니라, 객체는 메모리 할당에서 한 과정이 더 존재한다.
그 과정은 작성했던 [포스트][1]로 갈음하겠다. 이 내용에는 얕은 복사와 깊은 복사도 함께 다루고 있다.

### 📝 참조에 의한 전달

링크를 걸어둔 포스트를 읽어봤다면 알 수 있는데, 단순 할당을 하게 되면 다른 변수에서 객체를 변경하면 간섭이 생긴다는 것이다.

```javascript
var person = {
  name: "Lee",
};

var copy = person;

copy.name = "Kim";
```

`copy` 에 `person` 을 할당하는 과정에서, 참조 값(객체의 주소)을 복사하게 된다.
그래서 `copy` 에서 변경하면, `person` 에서도 반영이 되는 것이다.

서로 간섭을 없애고 싶다면 얕은 복사 or 깊은 복사(이중 객체)를 진행해야 한다.  
`Obejct1[key] = Object2[key]` 의 형태로 모조리 재할당 하는 것처럼 말이다.

이는 사실 앞에서 살펴본 값에 의한 전달과 다르지 않다.

단지 변수가 저장하고 있는 것이 원시값인지 참조값인지 차이가 있을 뿐이다.

다만, 참조값일 경우 참조에 의한 전달로 칭하고 원시값일 경우 값에 의한 전달로 칭하기로 하자.

[1]: https://kybaq.github.io/posts/JS-%EC%96%95%EC%9D%80-%EB%B3%B5%EC%82%AC-%EA%B9%8A%EC%9D%80-%EB%B3%B5%EC%82%AC/
