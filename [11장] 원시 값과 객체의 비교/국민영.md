# [11장] 원시 값과 객체의 비교

| 원시 타입(primitive type)               | 객체 타입(object/reference type) |
| --------------------------------------- | -------------------------------- |
| 변경 불가능 합 값                       | 변경 가능한 값                   |
| 변수(확보된 메모리 공간)에 실제 값 저장 | 참조 값 저장                     |
| 원본의 원시 값 복사되어 전달            | 참조에 의한 전달                 |

## ✅ 원시 값

### 📍 변경 불가능한 값

- 한번 생성된 원시 값은 읽기 전용 값으로서 변경 불가, 신뢰성이 높겠군
- 변경이 불가하다는 것은 변수가 아니라 값 (변경이 가능하니 이름도 변수 😄)
- 원시 값은 변경하려면 재할당만을 통해 변수 값을 교체(메모리 주소를 바꿔서 변수의 할당된 값을 교체)
- 상수는 재할당이 금지된 변수~!!!!!

- 프로퍼티에는 어떠한 값도 가능하며, 함수도 마찬가지다. 프로퍼티 값이 함수일 경우 구분을 위해 메서드라 부른다

### 📍 문자열과 불변성

> 문자열, 그리고 유사 배열 객체
> 유사 배열 객체란? 마치 배열처럼 인덱스로 프로퍼티값에 접근/ length프로퍼티를 갖는 객체

```jsx
// 예제 1
let str = "string";

// 유새 배열의 개념으로 접근은 가능하지만 문자열은 원시값이므로 변경은 불가. 에러는 뜨지 않고 변경도 이뤄지지 않는다
str[0] = "S";

console.log(str); // string
```

### 📍 값에 의한 전달

원시 값은 서로 다른 메모리 공간에 저장된 별개의 값이 되어 한쪽에서 재할당을 통해 값을 변경하더라도 서로 간섭 X

```jsx
let score = 80;

let copy = score;

console.log(score, copy); // 80 80
console.log(score === copy); // true

score = 100;

// 두 변수는 다른 메모리 공간에 저장된 별개의 값
// score의 값을 변경해도 copy에는 영향 없당
console.log(score, copy); // 100 80
console.log(score === copy); // false
```

## ✅ 객체

### 📍 변경 가능한 값

- 객체를 할당한 변수 "변수는 객체를 참조하고(or 가르키고) 있다"
- 객체는 변경 가능한 값이므로 재할당 없이 객체를 직접 변경(추가, 갱신, 삭제) 할 수 있다

```jsx
// - 프로퍼티 키 : 빈 문자열을 포함한 모든 문자열 또는 심벌 값
// - 프로퍼티 값 : JS에서 사용할 수 있는 모든 값

// 1. 식별자 네이밍 규칙을 따르지 않을 시 따옴표를 사용
// 네이밍 규칙을 따르지 않은 키가 따옴표를 사용하지 않았을시 SyntaxError 발생

const person = {
  "last-name": "Kim", // 식별자 네이밍 규칙을 따르지 않은 키
  name: "umo",
  age: 20,
};

// 2. 문자열 또는 문자열로 평가할 수 있는 표현식 사용 시 동적으로 키 값 생성 가능, 대괄호로 묶어야 함

// 동적으로 키 값을 생성하는 예시 코드
const dynamicKey = "name";

// 객체 생성
const person = {
  [dynamicKey]: "John", // 동적으로 키 값 생성
  age: 30,
};

console.log(person); // { name: 'John', age: 30 }
```

## ✅ 메서드

<p style="font-size : 0.8rem; color: #888; padding: px 0;">// 잠깐 미리 알고가는 일급객체 (추후에 자세히 다뤄진다 함)</p>

> **일급 객체(First-Class Object) :다른 객체들에 일반적으로 적용되는 연산을 모두 지원하는 객체**
>
> - 함수와 변수에 할당할 수 있고, 함수의 매개변수로 전달할 수 있으며, 함수의 반환 값으로 사용할 수 있음(즉, 함수도 값으로 사용 가능) <br/>
> - JavaScript에서는 함수가 일급 객체로 간주 <br/>
> - 함수에 대한 조작이 가능하며, 객체는 데이터와 그 데이터에 대한 조작을 모두 포함하는 개념 <br/>
> - JavaScript에서는 함수가 일급 객체이므로 함수를 변수에 할당하거나 매개변수로 전달하는 등의 작업을 자유롭게 할 수 있게하고, 이런 유연성은 JavaScript를 함수형 프로그래밍과 콜백 기반의 프로그래밍에 적합

**함수는 일급객체이기에 프로퍼티 값 역시 함수가 될수 있고, 이럴 경우 일반 함수와 구분을 위해 메서드라 부른다. 메서드는 객체에 묶여 있는 함수~!**

### 📍 프로퍼티 접근

```jsx
// 마침표 프로퍼티 접근 연산자(.)를 사용하는 마침표 표기법
// 대괄호 프로퍼티 접근 연산자[...]를 사용하는 대괄호 표기법

const person = {
  name: "Lee",
  'first-name': "umo",
}

// 마침표 표기법
console.log(person.name) // Lee

// 대괄호 표기법 이용시 따옴표르 감싸줘야 함, 따옴표로 감싸지지 않으면 ReferenceError
console.log(person.['name']) // Lee

// 존재하지 않은 프로퍼티에 접근시? undefined
console.log(person.age) // undefined

// 네이밍 규칙을 따르지 않은 프로퍼티에 접근시 당연히 대괄효 사용
console.log(person['first-name'])

// 브라우저 환경과 Node.js 환경
console.log(person.last-name) // 브라우저 환경 : NaN
console.log(person.last-name) // Node.js 환경 : Ref오류

// -> 우선 node.js 환경에서 person.last는 undefined를 반환하게 되고, 이를 숫자에서 빼는 연산으로 인식
// 그리고 name은 정의되지 않은 변수로 인식되어 참조 오류가 발생
// 따라서 Node.js 환경에서는 "ReferenceError: name is not defined"과 같은 오류가 발생

// 이와는 달리 브라우저 환경에서는 NaN이 출력되는데,
// 이는 person.last가 undefined를 반환하고,
// 숫자에서 undefined를 빼는 연산으로 인식되어 NaN이 출력되기 때문
```

## ✅ 프로퍼티 값 갱신

이미 존재하는 프로퍼티에 값을 할당하면 값이 갱신된다

```jsx
const person = {
  name: "Lee",
};

person.name = "Kim";

console.log(person); // {name: "Kim"}
```

## ✅ 프로퍼티 동적 생성

존재하지 않은 프로퍼티에 값을 할당하면 프로퍼티가 동적으로 생성되어 추가되고 값이 할당

```jsx
let person = {
  name: "Lee",
};

person.age = 20;

console.log(person); // {name: "Lee", age: 20}
```

## ✅ 프로퍼티 삭제

- delete 연산자로 프로퍼티 삭제
- delete 연산자의 피연산자는 프로퍼티 값에 접근할 수 있는 표현식이여야 함
- 만약 존재하지 않는 프로퍼티를 삭제한다해도 에러는 뜨지 않음

```jsx
let person = {
  name: "Lee",
  age: 20,
};

delete person.age; // age 프로퍼티가 존재하므로 삭제된다.

delete person.address; // address 프로퍼티가 존재하지 않으니 당연히 삭제되는건 없지만 에러가 발생하진 않는다

console.log(person); // {name: "Lee"}
```

## ✅ ES6에서 추가된 객체 리터럴의 확장 기능

### 📍 프로퍼티 축약 표현

```jsx
// ES5
var x = 1,
  y = 2;

var obj = {
  x: x,
  y: y,
};

console.log(obj); // {x: 1, y: 2

// ES6
let x = 1,
  y = 2;

// 변수 이름과 프로퍼티 키가 동일한 이름일때 축약하여 표현 가능
const obj = { x, y };

console.log(obj); // {x: 1, y: 2}
```

### 📍 계산된 프로퍼티 이름

문자열 또는 문자열로 타입 변환할 수 있는 값으로 평가되는 표현식을 사용해 동적으로 프로퍼티 키를 생성 가능
역시나 프로퍼티로 사용할 키는 대괄호로 묶어야 한다.

```jsx
// ES5의 계산된 프로퍼티 이름으로 키 동적 생성하는 예제
var prefix = "prop";
var i = 0;

var obj = {};

// 계산된 프로퍼티 이름으로 프로퍼티 키 동적 생성
obj[prefix + "-" + ++i] = i;
obj[prefix + "-" + ++i] = i;
obj[prefix + "-" + ++i] = i;

console.log(obj); // {prop-1: 1, prop-2: 2, prop-3: 3}

// ES6의 계산된 프로퍼티 이름으로 키 동적 생성하는 예제
const prefix = "prop";
let i = 0;

// 객체 리터럴 내부에서 계산된 프로퍼티 이름으로 프로퍼티 키 동적 생성
const obj = {
  [`${prefix}-${++i}`]: i,
  [`${prefix}-${++i}`]: i,
  [`${prefix}-${++i}`]: i,
};

console.log(obj); // {prop-1: 1, prop-2: 2, prop-3: 3}
```

### 📍 메서드 축약 표현

```jsx
// ES5
var obj = {
  name: "Lee",
  sayHi: function () {
    console.log("Hi~ " + this.name);
  },
};

obj.sayHi(); // Hi~ Lee

// ES6
const obj = {
  name: "Lee",
  // 메서드 축약 가능
  sayHi() {
    console.log("Hi~ " + this.name);
  },
};

obj.sayHi(); // Hi~ Lee
```
