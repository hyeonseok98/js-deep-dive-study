# [07장] 연산자
```
✅ 연산자(Operator): 하나 이상의 표현식을 대상으로 산술, 할당, 비교, 논리, 타입, 지수 연산 등을 수행해 하나의 값을 만듦
✅ 피연산자(Operand): 연산의 대상이며 값으로 평가될 수 있는 표현식이어야 함.
```

## 7.1 산술 연산자
- 산술 연산이 불가능 할 경우, NaN을 반환함

#### 이항 산술 연산자: 2개의 피연산자를 산술 연산하여 숫자 값을 만듦(+, -, *, /, %)
#### 단항 산술 연산자: 1개의 피연산자를 산술 연산하여 숫자 값을 만듦(++, --, +, -)
- ++와 --에는 피연산자의 값을 변경하는 부수 효과(side effect)가 있음
- +와 -에는 부수 효과가 없음(-의 경우 부호를 반전시킨 값을 생성해 반환함)

```
❓ - 단항 연산자는 값을 반전시키는데, 그럼 피연산자의 값이 바뀌는거 아닌가?

=> let a = 1; a++;을 실행하면 a++; 그 자체로 a라는 피연산자의 값이 바뀐다.
하지만 -의 경우 -a; 라는 실행 자체만으로 피연산자 a가 변하지 않는다. a는 여전히 1이다.
헷갈린 부분은 let a = -a;처럼 값을 재할당할 때 부호가 반전되니 값이 변하지 않을까?라는 부분이었다.
코딩 할 때 자연스럽게 변수 선언의 형태를 떠올려서 헷갈렸던 것.
```

### 문자열 연결 연산자
- '+ 연산자'는 피연산자 중 하나 이상이 문자열인 경우 문자열 연결 연산자로 동작함

```jsx
'1' + 2 // '12', 문자열 연결 연산자

1 + 2 // 3, 산술 연산자

1 + true // 2
1 + false // 1
1 + null // 1

/* undefined는 숫자로 타입 변환되지 않음 */
+undefined // NaN
1 + undefined // NaN
```
- '1 + true' 같이 연산이 불가능 해보이는 것도 개발자의 의도와 상관없이 자바스크립트 엔진에 의해 암묵적으로 타입이 변환되어 계산되기도 하는데,
이를 **암묵적 타입 변환(implicit coercion)** 또는 **타입 강제 변환**이라고 한다.

<br>

## 7.2 할당 연산자
- 우항에 있는 피연산자의 평가 결과를 좌항에 있는 변수에 할당(=, +=, -=, *=, /=, %=)
- 할당문은 값으로 평가된 표현식인 문으로서 할당된 값으로 평가됨
```jsx
var x;

// 할당문은 표현식인 문이다.
console.log((x = 10)); // 10
```

<br>

## 7.3 비교 연산자

| 연산자 | 의미             | 예제    |설명         |
| ------ | ---------------- | ------- | -------- |
| ==     | 동등 비교        | x == y  |x와 y의 값이 같음|
| ===    | 일치 비교        | x === y |x와 y의 값과 타입이 같음|
| !=     | 부동등 비교   | x != y  |x와 y의 값이 다름|
| !==    | 불일치 비교   | x !== y |x와 y의 값과 타입이 다름|

#### ✅ 동등 비교(==) 연산자는 좌항과 우항의 피연한자를 비교할 때 먼저 "암묵적 타입 변환"을 통해 타입을 일치시킨 후 같은 값인지 비교함
```jsx
5 == '5'; // true
5 === '5'; // false
5 != '5'; // false
5 !== '5'; // true
```
동등 비교 연산자는 편리한 경우도 있지만 결과를 예측하기 어려운 안티 패턴들도 있어 실수하기 쉽다. <br>
때문에 값을 비교할 때는 **일치 비교(===) 연산자**를 많이 사용한다

```jsx
false == '0' // true
false == 'false' // false
false == null // false
```
<br>

- NaN은 자신과 일치하지 않는 유일한 값이다.
- ES6에 도입된 Object.is메서드는 예측 가능한 정확한 비교 결과를 반환한다
```jsx
NaN === NaN /// false
Object.is(NaN, NaN) // true

// 0에는 양의 0이 있고 음의 0도 있다.
-0 === +0 // true
Object.is(-0, +0) // false
```
<br>

## 삼항 조건 연산자
```
✅ 다음과 같이 사용된다 => 조건식 ? 조건식이 true일 때 반환할 값 : 조건식이 false일 때 반환할 값
```
- if...else문과 유사하지만 중요한 차이가 있는데, 삼항 조건 연산자는 값처럼 사용 가능하지만, if...else문은 값처럼 사용할 수 없음

```jsx
let x = 10;

let reuslt1 = if(x % 2) { result = '홀수'; } else { result = '짝수'; }; // SyntaxError: Unexpected token if
let result2 = x % 2 ? '홀수' : '짝수"; // 짝수
```

<br>

## 7.5 논리 연산자
- 논리 연산자로는 ||(논리합, OR), &&(논리곱, AND), !(부정, NOT)가 있음

## 7.6 쉼표 연산자
- 쉼표(,) 연산자는 왼쪽 피연산자부터 차례대로 피연산자를 평가하고, 마지막 피연산자의 평가가 끝나면 마지막 피연산자의 평가를 반환함

## 7.7 그룹 연산자
- 소괄호()로 피연산자를 감싸 연산자의 우선순위를 높게 조절함

## 7.8 typeof 연산자
- 피연산자의 데이터 타입을 문자열로 반환함
- 'string', 'number', 'boolean', 'undefined', 'symbol', 'object', 'function' 중 하나를 반환
- 단, 반환하는 문자열이 데이터 타입과 정확하게 일치하진 않음
```jsx
typeof NaN // 'number'
typeof null // 'object'
typeof [] // 'object'
typeof new Date() // 'object'
typeof function() {} // 'function'
typeof undeclared // 선언하지 않은 식별자의 경우 'undefined'가 반환됨
```

<br>

## 7.9 지수 연산자
- 좌항의 피연산자를 밑(base)로, 우항의 피연산자를 지수(exponent)로 거듭 제곱하여 숫자 값을 반환함
- 지수 연산자는 이항 연산자 중에서 **우선순위가 가장 높음**
- 지수 연산자 도입 이전에는 Math.pow 메서드를 사용했음

```jsx
2 ** (3 ** 2) // 512, 지수 연산자의 결합 순서는 우항에서 좌항(우결합성)임.
Math.pow(2, Math.pow(3,2)) // 512

(-5) ** 2 // 음수를 base로 사용하려면 반드시 괄호로 묶어야 한다. 묶지 않으면 에러
```

## 7.11 연산자의 부수 효과
- 이 외 부수효과가 있는 연산자로는 delete 연산자가 있음
- delete 연산자는 객체의 프로퍼티를 삭제하는 부수 효과가 있음


## 7.12 연산자의 우선순위
- 연산자의 우선순위를 모두 기억하는 건 어렵고 실수할 여지도 높기 때문에,<br>
기억에 의존하는 것 보다 연산자 우선순위가 가장 높은 그룹 연산자를 사용하여 우선순위를 명시적으로 조절하는 것을 권장
