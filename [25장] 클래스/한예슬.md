## 25.7 프로퍼티

### ✔️ 인스턴스 프로퍼티

- 인스턴스 프로퍼티는 constructor 내부에 정의해야 한다.

```jsx
class Person {
  constructor(name) {
    //인스턴스 프로퍼티
    this.name = name;
  }
}

const me = new Person("Lee");
console.log(me); // Person {name: 'Lee'}
```

- constructor 내부에서 this에 추가한 프로퍼티는 언제나 클래스가 생성한 인스턴스의 프로퍼티가 된다.
- 인스턴스 프로퍼티는 언제나 public 하다.

### ✔️ 접근자 프로퍼티

: 자체적으로는 값(value) 을 갖지않고 다른 데이터 프로퍼티의 값을 읽거나 저장할 때 사용하는 접근자함수로 구성된 프로퍼티다.

- 접근자 함수 getter 함수와 setter 함수로 구성되어 있다.
  - **getter** : 인스턴스 프로퍼티에 접근할 때마다 프로퍼티 값을 조작하거나 별도의 행위가 필요할때 사용한다.
    - getter는 메서드 이름 앞에 get 키워드를 사용해 정의한다.
    - 호출하는 것이 아니라 프로퍼티처럼 참조하는 형식으로 사용한다.
    - 무언가를 취득할 때 사용하므로 반드시 무언가를 반환해야한다.
  - **setter** : 인스턴스 프로퍼티에 값을 할당할 때마다 프로퍼티 값을 조작하거나 별도의 행위가 필요할 때 사용한다.
    - setter는 메서드 이름 앞에 set 키워드를 사용해 정의한다.
    - 호출하는 것이 아니라 프로퍼티처럼 값을 할당하는 형식으로 사용한다.
    - 무언가를 프로퍼티에 할당해야 할 때 사용하므로 반드시 매개변수가 있어야한다.
    - setter 는 단 하나의 값만 할당받기때문에 단 하나의 매개변수만 선언할 수 있다.
  - 참조 / 할당시에 내부적으로 호출된다.

### ✔️ 클래스 필드 정의 제안

- 클래스 필드란?
  : 클래스 기반 객체지향 언어에서 클래스가 생성할 인스턴스의 프로퍼티를 가리키는 용어다.
- 자바의 클래스 필드는 마치 클래스 내부에서 변수처럼 사용된다.
- 자바스크립트의 클래스에서 인스턴스 프로퍼티를 선언하고 초기화하려면 반드시 constructor 내부에서 this에 프로퍼티를 추가해야한다.
- 인스턴스 프로퍼티를 참조하려면 반드시 this를 사용하여 참조해야 한다.
- 클래스 기반 객체지향 언어의 this 는 언제나 클래스가 생성할 인스턴스를 가리킨다.
- 클래스 몸체에는 메서드만 선언할 수 있다. -> 새로운 표준사양으로 최신 브라우저와 Node.js 에서는 클래스필드를 클래스 몸체에 정의할 수 있다.
- 클래스 몸체에서 클래스 필드를 정의하는 경우 this에 클래스 필드를 바인딩해서는 안된다.
- this는 클래스의 constructor 와 메서드 내에서만 유효하다.

```jsx
class Person {
  // 클래스 필드 정의
  name = "Lee";
}

const me = new Person();
console.log(me); // Person {name: "Lee"}
```

- 클래스 필드를 참조하는 경우 this 를 반드시 사용해야 한다.
- 클래스 필드에 초기값을 할당하지 않으면 undefined를 갖는다.
- 인스턴스를 생성할 때 외부의 초기값으로 클래스 필드를 초기화해야 할 필요가 있다면 constructor 에서 클래스 필드를 초기화해야 한다.<br>
  => 이처럼 인스턴스를 생성할때 클래스 필드를 초기화할 필요가 있다면, constructor 밖에서 클래스 필드를 정의할 필요가 없다. 어차피 constructor 내부에서 클래스 필드를 참조하여 초기값을 할당해야 한다.
- 이때 this, 즉 클래스가 생성한 인스턴스에 클래스 필드에 해당하는 프로퍼티가 없다면 자동 추가되기 때문이다.
- 함수는 일급객체이므로 함수를 클래스 필드에 할당할 수 있다.<br>
  -> 클래스 필드를 통해 메서드를 정의할 수도 있다. (권장 X)

### \* 인스턴스 프로퍼티를 정의하는 방식

1. 인스턴스를 생성할 때 외부 초기값으로 클래스 필드를 초기화할 필요가 있다면, constructor 에서 인스턴스 프로퍼티를 정의하는 기존방식 사용.
2. 외부 초기값으로 클래스 필드를 초기화할 필요가 없다면 기존의 constructor 에서 인스턴스 프로퍼티를 정의하는 방식과 클래스 필드 정의 제안 모두 사용할 수 있다.

### ✔️ private 필드 정의 제안

- js 는 캡슐화를 완전하게 지원하지 않는다.
- 클래스 내부에서만 참조할 수 있다.
- 클래스도 접근 제한자(private, public, protected)를 지원하지 않는다.
- 인스턴스 프로퍼티는 인스턴스를 통해 클래스 외부에서 언제나 참조할 수 있다.
- 언제나 public 이다.
- 반드시 클래스 몸체에 정의해야한다.
- private 필드의 선두에는 # 을 붙여준다.
- private 필드를 참조할때도 # 을 붙어주어야 한다.

```jsx
class Person {
  // private 필드 정의
  #name = "";

  constructor(name) {
    // private 필드 참조
    this.#name = name;
  }
}

const me = new Person("Lee");
console.log(me.#name);
```

## 25.8 상속에 의한 클래스 확장

: 기존 클래스를 상속받아 새로운 클래스를 확장하여 정의하는 것이다.

- 프로토타입 기반 상속과는 다른 개념.
- `프로토타입 기반 상속`은 `프로토타입 체인`을 통해 `다른 객체의 자산을 상속`받는 개념이지만, `상속에 의한 클래스 확장`은 `기존 클래스를 상속받아 새로운 클래스를 확장`하여 정의하는 것이다.
- 클래스는 상속을 통해 다른 클래스를 확장할 수 있는 문법인 extends 키워드가 기본적으로 제공된다. -> 간편하고 직관적이다.

### ✔️ extends 키워드

: 수퍼클래스와 서브클래스간의 상속 관계를 설정하는 것.

- 상속을 통해 클래스를 확장하려면 extends 키워드를 사용하여 상속받은 클래스를 정의한다.
- 상속을 통해 확장된 클래스를 서브클래스(파생 클래스 / 자식 클래스)라 부르고, 서브클래스에게 상속된 클래스를 수퍼클래스(베이스 클래스 / 부모 클래스)라 부른다.

```jsx
// 수퍼(베이스/부모) 클래스
class Base {}

// 서브(파생/자식) 클래스
class Derived extends Base {}
```

### ✔️ 동적 상속

- extends 는 생성자 함수를 상속받아 클래스를 확장할 수도 있다.
- extends 키워드 앞에는 반드시 클래스가 와야한다.
- extends 키워드 다음에는 클래스 뿐만 아니라 [[Construct]] 내부 메서드를 갖는 함수 객체로 평가될 수 있는 모든 표현식을 사용할 수 있다.<br>
  -> 이를 통해 동적으로 상속받을 대상을 결정할 수 있다.

```jsx
function Base() {}
class Base2 {}
let condition = true;

// 조건에 따라 동적으로 상속대상을 결정하는 서브클래스
class Derived extends (condition ? Base1 : Base2) {}
```
