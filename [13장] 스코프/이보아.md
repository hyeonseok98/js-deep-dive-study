# [12장] 함수

## 13.1 스코프란? (유효 범위)
> 모든 식별자 (변수 이름, 함수 이름, 클래스 이름 등) **자신이 선언된 위치에 의해 다른 코드가 식별자 자신을 참조할 수 있는 유효 범위**가 결정된다. 

```javascript
let x = 'global'

function foo() {
 let x = 'local';
console.log(x)
}

foo();

console.log(x);
```
📄 식별자 결정(identifier resolution) : 위의 예시처럼 동일한 변수 x가 있을때 어떤 변수를 참조해야 할 것인지를 결정하는것 

![image](https://github.com/hyeonseok98/js-deep-dive-study/assets/71476841/ca57315e-c163-4e8e-9d31-737ab72d967a)
![image](https://github.com/hyeonseok98/js-deep-dive-study/assets/71476841/ca7151dc-ff70-4578-a7df-5d703e54ca36)

### ❗var 키워드로 선언한 변수의 중복 선언 
- var 키워드로 선언된 변수는 같은 스코프 내에서 중복 선언을 허용한다.
- 아래 변수 선언문은 자바스크립트 엔진에 의해 var 키워드가 없는 것처럼 동작함 
```javascript
function foo() {
 var x = '1';

 var x = '2';
console.log(x) //2 
}
foo()
```

### 13.2.1 스코프의 종류 (Global vs Local )
> 전역과 지역으로 구분할 수 있다. -> 전역 변수는 어디서든지 참조할 수 있다. 

![image](https://github.com/hyeonseok98/js-deep-dive-study/assets/71476841/b7e8efb8-0dac-42e7-aef1-1bc3cb21e7e2)

### 13.2.2 지역과 지역 스코프
> 함수 몸체 내부를 말함. 지역 변수는 자신의 지역 스코프와 하위 지역 스코프에서 유효하다. 

## 13.3 스코프 체인
> 스코프가 함수의 중첩에 의해 계층적 구조를 갖는다<br>

👉 변수를 참조할 때 자바스크립트 엔진은 스코프 체인을 통해 변수를 참조하는 코드의 스코프에서 시작하여 
    상위 스코프 방향으로 이동하며 선언된 변수를 검색(identifier resolution)한다.

  📄 렉시컬 환경: 스코프 체인은 실행 컨텍시트의 렉시컬 환경을 연결한 것이다. 변수 선언이 실행되면 변수 식별자가 
      이 자료구조(렉시컬 환경)에 키로 등록이 되고, 변수 할당이 일어나면 이 자료구조의 변수 식별자에 해당하는 값을 변경한다. <br>
      
### 스코프 체인에 의한 변수 검색, 함수 검색 
> 식별자를 검색하는 규칙 
> 상위 스코프에서 유효한 변수는 하위 스코프에서 자유롭게 참조할 수 있지만 하위 스코프에서 유효한 변수를 상위 스코프에서 참조할 수 없다.

![image](https://github.com/hyeonseok98/js-deep-dive-study/assets/71476841/aad58e3e-adad-4aa2-8494-5826e8dedb4a)

> 높은 망루에선 낮은 위치의 성채 내부와 바깥에 뭐가 있는지 관찰(참조)할 수 있다. 그러나 성벽에 시야가 가리기 때문에 바깥에서 내부를 관측할 수 없다. 함수의 코드 블럭은 성벽과 같다. 
    코드 블럭 안쪽에 있을 수록 바깥을 관측할 순 있지만 코드 블럭 바깥에서 내부의 변수를 참조할 순 없다.
    블록 스코프에서 지역 변수 y는 전역 변수 x값을 참조할 수 있고, 반환되는 함수의 지역 변수z는 y의 값을 참조할 수 있다.

  ![image](https://github.com/hyeonseok98/js-deep-dive-study/assets/71476841/70a8fd84-3154-4f67-8fc9-43fd96925005)

  > 높은 망루(내부 코드 블럭)에 있더라도 완전히 다른 코드 블럭에 속해있는 지역 변수를 참조할 순 없다. 코드 블럭의 실행은 독립적이며 실행이 끝나면 더 이상 참조할 수 없기 때문에 더욱이 다른 위치에서 참조할 수 없다.
    자신이 속해있는 지역의 변수들을 참조할 수 있게 되며, 해당 코드 레벨에 참조값이 없다면 상위 레벨의 스코프로 참조 값을 찾아 나가는 현상을 스코프 체인(Scope Chain)이라고 한다. 전역 스코프에도 참조값이 없다면 null을 반환하게 된다.

[참조 블로그](https://velog.io/@oneook/%EC%8A%A4%EC%BD%94%ED%94%84%EC%99%80-%EC%8A%A4%EC%BD%94%ED%94%84-%EC%B2%B4%EC%9D%B8-JavaScript-Basics)


## 13.4 함수 레벨 스코프
> 코드 블록이 아닌 함수에 의해서만 지역 스코프가 생성된다. -> 오로지 함수의 코드 블록(함수 몸체)만 지역 스코프로 인정함

```javascript
 var x = 1;

if( true){
   var x = 10;
// -> var 키워드로 선언된 변수는 함수의 코드 블록을 지역 스코프로 인정한다.
// 힘수 밖에서 var 키워드로 선언된 변수는 코드 블록 내에서 선언되었다 할지라도 모두 전역 변수임
// -> 이미 선언된 x에 중복 선언이 되고 이는 의도치않게 값을 변경시킴 -> 그러나 let, const 블랙 레벨 스코프를 지원함
}

console.log(x); //10
```
## 13.5 렉시컬 스코프 
> 자바스크립트는 렉시컬 스코프 원칙을 따른다. 렉시컬 스코프는 또 다른 말로 정적 스코프(Static Scope)라고 한다. <br>

```javascript
let x = 1;

//-> 함수를 어디서 정의했는지가 중요
function foo(){
 let x = 10;
  bar(); -> 렉시컬 스코프는 호출했는지가 중요하지 X
}

//-> 함수를 어디서 정의했는지가 중요
function bar(){
 console.log(x);
}

foo() // 1 
bar() // 1
```

- 함수가 어디서 호출했는지가 아니라 **함수를 어디서 정의했는지에 따라 상위 스코프 결정**
- 함수가 호출된 위치는 상위 스코프 결정에 어떠한 영향도 주지 않는다 -> 함수의 상위 스코프는 언제나 자신의 정의된 스코프
- 함수 상위 스코프는 함수 정의 실행될 때 정적으로 결정됨
- 함수 정의가 실행된 상위 스코프를 기억 -> 호출 시 함수의 상위 스코프를 참조해야함

