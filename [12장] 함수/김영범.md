# [12장] 함수

## 12.1 함수란?

자바스크립트의 함수로 바로 넘어가보자.

```javascript
function add(x, y) {
  return x + y;
}

add(2, 5); // 7
```

수학에서의 함수처럼, 입력에 대해 연산을 진행한 결과인 출력이 존재한다.  
프로그래밍 관점에서 설명을 해보자면,

    💡 일련의 과정을 문(statement)으로 구현하고 코드 블록으로 감싼 하나의 실행 단위

라고 할 수 있겠다.

예시를 다시 한 번 가져와, 함수의 구성 요소에 대해 살펴보자.

```javascript
function add(x, y) {
  // function: 함수 선언 키워드
  // add: 함수 이름
  // (x, y): 매개 변수 목록
  return x + y;
  // x + y: 함수의 반환값, 이때 `return 반환값` 형태로 사용해주어야함.
}

add(2, 5); // 7
// 2, 5: 함수의 인자
```

위 형태 처럼 함수를 정의하는 것을 **함수 선언문**이라고 한다.  
그리고, `add(2,5)` 처럼 함수를 실행하는 것을 **함수 호출**이라고 한다.

## 12.2 함수를 사용하는 이유?

> 이 역시도, 변수 처럼 코드의 재사용성을 높이기 위해서다.  
> 연산이나 기능이 복잡해질수록 코드는 길어지기 마련인데, 매번 다시 작성할 필요 없이 사용하면 좋으니까!  
> 또한, 코드의 가독성 또한 증가한다. 함수의 기능을 한 번 파악하면, 그 함수 호출만해도 의도 파악이 쉬워지니까!

## 12.3 함수 리터럴

방금 살펴본 함수 선언문 말고도, **함수 표현식** 도 존재한다.

```javascript
const add = function (x, y) {
  return x + y;
};

add(2, 5); // 7
```

함수 선언문 형태로 정의한 것을 함수 표현식으로 바꾸어 정의했다.

이때, 독특한 것은 함수를 변수 `add`에 대입해도 문제가 없다는 것이다.
자바스크립트 함수는 일급 객체라고 부른다. 변수에 값을 대입하는 것처럼 사용이 가능하다.

자세한 것은 18장에서 다루어보자.

## 12.4 함수 정의

> 자바스크립트에서 변수는 선언(declaration)하고, 함수는 정의(definition)한다고 표현한다.

함수를 정의하는 방법은 앞서 확인한 함수 선언문, 함수 표현식을 포함해 4가지 정도 있다.

1. 함수 선언문

```javascript
function add(x, y) {
  return x + y;
}

add(2, 5); // 7
```

함수 선언문에서는 함수 이름을 생략하면 안된다. 또한, 이름에서 알 수 있듯이 statement 다.  
브라우저 콘솔에서 함수 선언문을 작성하면, `undefined` 가 출력이 되는데 이는 표현식이 아니기에 값으로 평가되지 않고 완료 값인 `undefined` 가 출력이 되는 것이다.

따라서, 함수 선언문은 값이 아니기에 변수 할당이 불가능하다.

2. 함수 표현식

```javascript
const add = function (x, y) {
  return x + y;
};

add(2, 5); // 7
```

함수 표현식에서는 함수 선언문 형태에서 이름은 제외해도 문제 없다.
함수 표현식에서는 값으로 평가되어 변수 할당이 가능해진다.

이때, 변수 명이 함수 이름이 된다.

❗잠깐, 함수 표현식형태로 쓸 때 함수 이름을 대입하면 어떻게 될까?❗

```javascript
const add = function abc(x, y) {
  return x + y;
};

add(2, 5); // 7
abc(2, 5); // ReferenceError: abc is not defined
```

위 처럼 작성하더라도, 문제없이 할당이 된다.
함수 선언문으로 해석된 것이 아니고, 표현식 형태로 평가되었기 때문이다.

따라서, 함수 선언문 형태로 이름을 붙인 abc 로는 함수 호출이 불가능하다.

`{}` 자바스크립트에서 다양하게 사용되는데 상황에 따라 단순 코드 블록으로 해석될 수 있고, 객체 리터럴일 수도 있고 지금처럼 함수 리터럴이 될 수 도 있다.

지금은 문제가 없지만, 혼용해서 쓴다면 자바스크립트 엔진이 해석을 의도와 다르게 해석할 수 있으니 조심해야한다.

아래 예시를 보자.

```javascript
function foo() {
  console.log("foo");
} // 함수 선언문

foo(); // 'foo'

(function bar() {
  console.log("bar");
});

bar(); // ReferenceError: bar is not defined
```

함수 `foo()` 는 일반적인 함수 선언문 형태이기에 문제 없이 호출 되었다.  
하지만, `bar()` 의 경우 그룹 연산자(소괄호, `()`) 내부에 함수를 정의했다.

그런데, 소괄호 내부에 있는 코드는 표현식이어야 한다.  
따라서 자바스크립트 엔진은 함수 선언식을 통째로 표현식으로 평가했고, `bar()` 함수를 가리키는 식별자가 존재하지 않게된 것이다.

`foo()` 처럼 올바르게 함수 선언문으로 해석 된다면, 자바스크립트가 함수 이름을 식별자로서 생성해준다.
그래서 함수 이름으로 호출이 가능하게 되는 것이다.

함수 선언문과 함수 표현식을 통해 함수를 정의할 수 있지만, 이 과정이 완벽히 동일하지 않다.

이는 함수 호이스팅으로 살펴볼 수 있다.

### 📝 함수 생성 시점과 함수 호이스팅

```javascript
// 함수 참조
console.dir(add); // f add(x,y)
console.dir(sub); // undefined

// 함수 호출
console.log(add(2, 5)); // 7
console.log(sub(2, 5)); // TypeError: sub is not a function

// 함수 선언문
function add(x, y) {
  return x + y;
}

// 함수 표현식
const sub = function (x, y) {
  return x - y;
};
```

이전에 변수의 호이스팅에 대해 다룰 때 언급한 것 처럼, 함수 역시 호이스팅이 일어난다.
근데, 함수 선언문과 함수 표현식 간의 차이가 존재한다.

예시를 보면, 함수 선언문으로 정의한 경우에는 호출이 성공적으로 이루어진다.
반면, 함수 표현식은 그렇지 않다.

함수 선언문의 호이스팅은 함수 몸체 전부가 코드 최상단으로 끌어올려진다.
그렇기 때문에 함수가 먼저 생성되고 코드가 실행된다.

그러나, 함수 표현식은 마치 변수처럼 선언부(`const sub`)만 호이스팅이 일어나고 런타임에 할당이 되며 함수 생성이 돼 차이가 발생한다.

함수 선언문으로 작성했을 때, 함수 정의보다 앞서 호출을 하더라도 문제가 되지 않기 때문에 대부분 함수 표현식으로 작성하도록 권장한다.
그래야 코드 흐름 파악이 쉬우니까!

아직 함수를 정의하는 2개의 방법 밖에 살펴보지 않았다. 나머지 2개가 더 있다.

3. 생성자 함수

```javascript
var add = new Function("x", "y", "return x + y");
```

생성자 함수를 이용하면, 클로저(closure)를 생성하지 않는다고 한다.
게다가, 함수 선언문이나 함수 표현식으로 정의한 함수와 다르게 동작한다고 한다.

이는 추후에 알아보자.

4. 화살표 함수

```javascript
var add = (x, y) => x + y;
// 코드 블럭(중괄호, {}) 를 사용하지 않으면 return 작성하지 않아도 됨.
// 그러나, 코드블럭을 사용하면 return 을 명시하는 것이 좋다.
```

함수 표현식을 보다 간결하게 작성할 수 있으며, 내부 동작 또한 간략화한 형태다.
함수 생성 시점에 this binding 이 이루어지지 않는 등 일반 함수 표현식과 다르다.

이 또한 추후에 다루자.
