# [12장] 함수

> 자바스크립트에서 가장 중요한 핵심 개념으로 **스코프, 실행 컨텍스트, 클로저, 생성자 함수에 의한 객체 생성, 메서드, this, 프로토타입, 모듈화** 등이 함수와 관련이 있다.

## 12.1 함수란?
- 함수는 일련의 과정을 문(statement)으로 구현하고 특정 작업을 수행하거나 값을 계산하는 코드 블록으로 감싸서 하나의 실행 단위로 정의한 것
- 독립적인 코드 단위로 정의할 수 있으며, 필요할 때마다 호출하여 재사용 가능
- 자바스크립트에서 함수는 일급 객체로 취급되어, **변수에 할당** 하거나 **다른 함수의 인수로 전달** 하거나 **반환값으로 사용** 가능

![image](https://github.com/hyeonseok98/js-deep-dive-study/assets/144431560/9b231705-9a18-448b-8860-d6713b08a40d)

## 12.2 함수를 사용하는 이유
1. 코드 재사용성
2. 코드 가독성
3. 유지보수 편의성
4. 코드 신뢰성

- 함수 정의(function definition)
```javascript
// 함수 선언문
function add(x, y) {
  return x + y;
}
```

- 함수 호출(function call/invoke)

argument를 parameter를 통해 함수에 전달하면서 함수의 실행을 명시적으로 지시 해야 함.
```javascript
// 함수 호출
var result = add(2, 5);

// 함수 add에 인수 2, 5를 전달하면서 호출하면 반환값 7을 반환한다.
console.log(result); // 7
```
함수를 호출하면 코드 블록에 담긴 문들이 일괄적으로 실행되고 실행 결과(반환값)를 반환함.

## 12.3 함수 리터럴
- 자바스크립트의 함수는 객체 타입의 값
- 따라서, 함수도 함수 리터럴로 생성 가능
- 단, 일반 객체와 달리 함수는 호출 할 수 있고, 함수 객체만의 고유한 프로퍼티를 가짐

```javascript
// 변수에 함수 리터럴을 할당
var f = function add(x, y) {
  return x + y;
};
```
ℹ️ 함수 리터럴 = 함수 표현식
- function 키워드
- 함수 이름
- 매개 변수 목록
- 함수 몸체로 구성

## 12.4 함수 정의
- 함수를 호출하기 이전 인수를 전달받을 매개변수와 실행할 문들, 그리고 반환할 값을 지정하는 것.
- 정의된 함수는 자바스크립트 엔진에 의해 평가되어 함수 객체가 됨.

### 12.4.1 함수 선언문
```javascript
function add(x, y) {
return x + y;
}
```
- 함수 리터럴과 형태가 동일
- 차이점은 함수 리터럴은 함수 이름 생략 가능
- 함수 이름 생략 불가능
- 표현식이 아닌 문임 (개발자 도구 콘솔에서 함수 선언문을 실행하면 완료 값 undefined가 출력됨)

❗️ 함수 선언문이 만약 표현식인 문이라면 완료 값 undefined 대신 표현식이 평가되어 생성된 함수가 출력되어야 함. 표현식은 생성된 함수가 출력됨

```javascript
// 함수 선언문은 표현식이 아닌 문이므로 변수에 할당할 수 없다.
// 하지만 함수 선언문이 변수에 할당되는 것처럼 보인다.
var add = function add(x, y) {
  return x + y;
}; // 자바스크립트 엔진은 중괄호 부분을 객체 리터럴로 해석한다.

// 함수 호출
console.log(add(2, 5)); // 7
```
ℹ️ 위 예제는 함수 선언문을 변수에 할당하는 것처럼 보이는데, 사실 객체 리터럴 즉, 함수 표현식으로 해석한다.<br />
코드블록{ }은 두가지 의미가 있는데 코드 블록일 수도 있고 객체 리터럴일 수도 있다.(중의적 표현)<br />
{ }이 값으로 평가되어야 할 문맥에서 피연산자로 사용되면 엔진은 { }을 객체 리터럴로 해석한다.

**함수 리터럴도 마찬가지로 중의적인 코드** 이다.<br />
함수 이름이 있는 함수 리터럴을 단독으로 사용하면(변수 할당X) 함수 선언문으로 해석하고,<br />
함수 리터럴을 변수에 할당하거나 피연산자로 사용하면 함수 리터럴 표현식으로 해석한다.<br />

❗️ 함수 선언문과 함수 표현식 차이
- 함수 선언문은 함수 이름 생략 불가
- 함수 표현식(함수 리터럴)은 함수 이름은 함수 몸체 내에서만 참조 할 수 있는 식별자 라는 특성이 있어, 별도로 변수에 할당받지 않은 이상 호출할수 있는 식별자가 없음

```javascript
// 기명 함수 리터럴을 단독으로 사용하면 함수 선언문으로 해석된다.
// 함수 선언문에서는 함수 이름을 생략할 수 없다.
function foo() { console.log('foo'); }
foo(); // foo

// 함수 리터럴을 피연산자로 사용하면 함수 선언문이 아니라 함수 리터럴 표현식으로 해석된다.
// 함수 리터럴에서는 함수 이름을 생략할 수 있다.
(function bar() { console.log('bar'); });
bar(); // ReferenceError: bar is not defined

// 아래와 같이 작성해야 호출 가능하다.
bar = (function bar(){ console.log('bar'); });
bar(); // bar
```

### 12.4.2 함수 표현식 (function expression)
```javascript
// 함수 표현식
var add = function (x, y) {
  return x + y;
};

console.log(add(2, 5)); // 7
```
- 함수는 값처럼 변수에 할당할 수도 있고 프로퍼티 값, 배열의 요소가 될 수도 있음 (일급 객체)
- 함수 표현식은 함수 리터럴로 생성한 함수 객체를 변수에 할당하는 것

```javascript
// 기명 함수 표현식
var add = function foo (x, y) {
  return x + y;
};

// 함수 객체를 가리키는 식별자로 호출
console.log(add(2, 5)); // 7

// 함수 이름으로 호출하면 ReferenceError가 발생한다.
// 함수 이름은 함수 몸체 내부에서만 유효한 식별자다.
console.log(foo(2, 5)); // ReferenceError: foo is not defined
```
- 익명 함수: 함수 리터럴의 함수 이름 생략
- 함수 표현식의 함수 리터럴은 함수 이름을 생략하는 것이 일반적

## 12.4.3 함수 생성 시점과 함수 호이스팅
- 함수 선언문으로 정의한 함수는 함수 선언문 이전에 호출 가능
- 함수 표현식으로 정의한 함수는 함수 표현식 이전에 호출 불가
- 함수 선언문으로 정의한 함수와 함수 표현식으로 정의한 함수의 생성 시점이 다름

```javascript
// 함수 참조
console.dir(add); // ƒ add(x, y)
console.dir(sub); // undefined

// 함수 호출
console.log(add(2, 5)); // 7
console.log(sub(2, 5)); // TypeError: sub is not a function

// 함수 선언문
function add(x, y) {
  return x + y;
}

// 함수 표현식
var sub = function (x, y) {
  return x - y;
};
```
##### 함수 호이스팅(function hoisting)
함수 선언문은 런타임 이전에 함수 객체가 먼저 생성<br />
-> 함수 이름과 동일한 이름으로 식별자를 생성하고 생성된 함수 객체를 할당<br />
-> 즉, 코드가 실행되는 런타임시점에는 이미 함수 객체가 생성되어 있고 식별자에 할당까지 완료된 상태<br />
-> 함수 선언문이 코드의 선두로 끌어 올려진 것처럼 동작

##### 함수 선언문과 함수 표현식
**함수 선언문은 코드(함수 선언문을 포함한) 평가 단계**에서 함수 객체 생성.
**함수 표현식은 코드(함수 표현식을 포함한) 실행 단계**에서 함수 객체 생성.

##### 함수 호이스팅 vs 변수 호이스팅
- var키워드를 사용한 변수 선언문과 함수 선언문은 런타임 이전에 엔진에 의해 먼저 실행되어 식별자를 생성하는 점은 동일하다.
- 하지만, var키워드로 선언된 변수는 undefined로 초기화되고, 함수 선언문은 함수 객체로 초기화 된다.
- 따라서, var키워드를 사용한 변수는 선언문 이전에 참조하면 undefined로 평가되지만, 함수 선언문은 함수 호이스팅에 의해 호출이 가능하다.

##### 함수 표현식
- 함수 표현식은 변수에 할당되는 값이 함수 리터럴. 즉, 문이다.
- 따라서 변수 선언문과 할당문을 한번에 기술한 표현과 동일하게 동작한다.
- 변수 선언은 런타임 이전에 실행되어 undefined로 초기화 되고, 변수 할당문이 실행되는 시점, 즉 런타임 시점에 함수 표현식의 함수 리터럴이 평가되어 함수 객체가 변수 할당문의 값이 되어 할당된다.
- 결과적으로 함수 표현식은 함수 호이스팅이 발생되지 않고 변수 호이스팅만 발생된다.

✅ 함수 호이스팅은 함수를 호출하기 전에 반드시 함수를 선언해야 한다는 규칙을 무시하기 때문에 **함수 선언문 보다는 함수 표현식의 사용을 권장**

### 12.4.4 Function 생성자 함수
```javascript
var add = new Function('x', 'y', 'return x + y');

console.log(add(2, 5)); // 7
var add1 = (function () {
  var a = 10;
  return function (x, y) {
    return x + y + a;
  };
}());

console.log(add1(1, 2)); // 13

var add2 = (function () {
  var a = 10;
  return new Function('x', 'y', 'return x + y + a;');
}());

console.log(add2(1, 2)); // ReferenceError: a is not defined
```
Function 생성자 함수로 생성한 함수는 클로저를 생성하지 않는 등, 선언문이나 표현식으로 생성한 함수와 다르게 동작함.

### 12.4.5 화살표 함수
ES6에서 도입. 간략한 방법으로 함수 선언 가능. 항상 익명 함수로 정의함.
```javascript
const add = (x, y) => x + y;
console.log(add(2, 5)); // 7
```
- 화살표 함수는 생성자 함수로 사용할 수 없음
- 기존 함수와 this 바인딩 방식이 다름
- prototype 프로퍼티 X
- arguments 객체 생성 X


## 12.5 함수 호출
- 함수를 기리키는 식별자와 한 쌍의 소괄호인 함수 호출 연산자로 호출
- 0개 이상의 인수를 쉼표로 구분해서 나열
- 함수를 호출하면 현재 실행 흐름을 중단하고 호출된 함수로 실행 흐름을 옮김
- 이 때 매개변수에 인수가 순서대로 할당되고 함수 몸체의 문들이 실행

### 12.5.1 매개변수와 인수
- 함수 실행을 위해 필요한 값을 함수 외부에서 내부로 전달할 필요가 있는 경우, 매개변수(parameter, 인자)를 통해 인수(argument)를 전달
- 인수는 값으로 평가될 수 있는 표현식이어야 함
- 인수는 함수를 호출할 때 지정하며, 개수와 타입에 제한 X

```javascript
// 함수 선언문
function add(x, y) {
  return x + y;
}

// 함수 호출
// 인수 1과 2는 매개변수 x와 y에 순서대로 할당되고 함수 몸체의 문들이 실행된다.
var result = add(1, 2);
```
- parameter는 함수를 정의할 때 선언, 함수가 호출되면 몸체 내에서 암묵적으로 parameter가 생성되고 일반 변수와 마찬가지로 undefined로 초기화된 후 argument가 순서대로 할당됨
- parameter의 스코프는 함수 내부
![image](https://github.com/hyeonseok98/js-deep-dive-study/assets/157561573/a4b2c3e2-d7e7-4576-bf94-e4e929631b40)
- 함수는 parameter의 개수와 argument의 개수가 일치하는지 체크하지 않음. argument가 부족해서 할당되지 않은 parameter의 값은 undefined.


