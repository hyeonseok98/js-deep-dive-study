# 프로미스

> 자바스크립트는 비동기 처리를 위한 하나의 패턴으로 `콜백 함수`를 사용한다.<br>
> 하지만 전통적인 콜백 패턴은 콜백 헬로 인해 가독성이 나쁘고 비동기 처리 중 발생한 에러의 처치가 곤란하며,<br> 여러 개의 비동기 처리를 한번에 처리하는 데도 한계가 있기 때문에 `프로미스`가 등장하였다.<br>

- 프로미스는 콜백패턴이 가진 단점을 보완하며, `비동기 처리 시점을 명확하게 표현`할 수 있다는 장점이 있다.

## \* 비동기 처리를 위한 콜백 패턴의 단점

### ✔️ 콜백 헬

- 비동기 함수를 호출하면 함수 내부의 비동기로 동작하는 코드가 완료되지 않았다 해도 기다리지 않고 즉시 종료된다.

```jsx
let g = 0;

setTimeout(() => {
  g = 100;
}, 0);
console.log(g); // 0
```

- 비동기함수란?<br>
  -> 함수 내부에 비동기로 동작하는 코드를 포함한 함수.

- 위처럼 비동기 함수 내부의 비동기로 동작하는 코드에서 `처리 결과를 외부로 반환`하거나 `상위 스코프의 변수에 할당`하면 기대한 대로 동작하지 않는다.

- 이처럼 콜백 함수를 통해 비동기 처리 결과에 대한 후속 처리를 수행하는 `비동기 함수가 비동기 처리결과를 가지고 또 다시 비동기 함수를 호출`하여 복잡해지는 현상을 `콜백 헬`이라 한다.

### ✔️ 에러 처리의 한계

- 비동기 처리를 위한 콜백 패턴의 문제점 중에서 가장 심각한 것은 에러 처리가 곤란하다는 것이다.

```jsx
try {
  setTimeout(() => {
    throw new Error("error");
  }, 1000);
} catch (e) {
  // 에러를 캐치하지 못한다.
  console.log(error);
}
```

### ✔️ 프로미스의 생성

- Promise는 ECMAScript 사양에 정의된 표준 빌트인 객체다.
- Promise 생성자 함수는 비동기 처리를 수행할 콜백함수를 인수로 전달받는데 이 콜백함수는 `resolve`와 `reject` 함수를 인수로 전달받는다.

```jsx
// 프로미스 생성
const promise = new Promise((resolve, reject) => {
  // Promise 함수의 콜백 함수 내부에서 비동기 처리를 수행한다.
  if(비동기 처리 성공){
    resolve('result')
  } else {
    reject('failure reason')
  }
})
```

- 비동기 처리가 성공하면 resolve 함수를 호출하고 비동기 처리가 실패하면 reject 함수를 호출한다.<br>
  -> 이처럼 프로미스 상태는 resolve 또는 reject 함수를 호출하는 것으로 결정된다.

### 비동기 작업이 가질 수 있는 3가지 상태

### Pending(대기 상태) -> 프로미스가 생성된 직후 기본상태

### Fulfilled(성공) -> resolve 함수 호출

### Rejected(실패) -> reject 함수 호출

- Pending 상태에서 Fulfilled로 해결이 되었을 때는 `reslove` 가 된 것이고
- Pending상태에서 Rejected상태로 거부 되었을 때는 `reject` 된 것이다.
  - 이처럼 프로미스 상태는 resolve 또는 reject 함수를 호출하는 것이다.
- settled 상태 : fulfilled / resected 상태와 상관없이 pending 이 아닌 상태로 비동기 처리가 수행된 상태를 말한다.
- 프로미스는 pending 상태에서 fulfilled 또는 rejected 상태, 즉 settled 로 상태로 변화할 수 있다.

### ✔️ Promise

- 어떤 함수가 Promise를 반환한다는 것은 `그 함수는 비동기적으로 동작`을 하고 반환한 Promise객체를 이용해서 비동기 처리의 결과 값을 then과 catch로 이용하겠다는 의미이다.

## \* 프로미스의 후속 처리 메서드

### ✔️ Promise.prototype`.then`

- then 메서드는 두 개의 콜백 함수를 인수로 전달받는다.

- `첫번째 콜백` 함수: 프로미스가 `fulfilled` 상태가 되면 호출되고 프로미스의 비동기 처리 결과를 인수로 전달받는다.
- `두번째 콜백` 함수: 프로미스가 `rejected` 상태가 되면 호출되고 프로미스의 에러를 인수로 전달받는다.
- `then` 메서드는 언제나 프로미스를 반환한다.

### ✔️ Promise.prototype`.catch`

catch 메서드의 콜백함수는 프로미스가 `rejected` 상태인 경우만 호출된다.

### ✔️ Promise.prototype`.finally`

finally 메서드의 콜백 함수는 프로미스의 성공 혹은 실패와 상관없이 `무조건 한 번 호출`된다.

### ✔️ 프로미스의 에러 처리

- catch 메서드를 모든 then 메서드를 호출한 이후에 호출하면 비동기 처리에서 발생한 에러 뿐만 아니라 then 메서드 내부에서 발생한 에러까지 모두 캐치할 수 있다.
- catch 메서드를 사용하는 것이 또한 가독성이 좋고 명확하다.

### ✔️ 프로미스 체이닝

- 후속처리 메서드를 통해 콜백헬을 해결한다.
- 후속처리 메서드는 언제나 프로미스를 반환하므로 연속적으로 호출할 수 있다.
- then, catch, finally 후속 처리 메서드는 언제나 프로미스를 반환하므로 연속적으로 호출할 수 있다.
  -> 이를 프로미스 체이닝이라 한다.

```jsx
const url = "https://jsonplaceholder.typicode.com";

promiseGet(`${url}/posts/1`)
  .then(({ userId }) => promiseGet(`${url}/users/${userId}`))
  .then((userInfo) => console.log(userInfo))
  .catch((err) => console.error(err));
```
