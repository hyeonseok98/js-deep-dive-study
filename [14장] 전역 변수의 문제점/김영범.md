# [14장] 전역 변수의 문제점

> 스코프에 대해 배웠으니, 전역 변수는 왜 사용하지 않는지도 알아보자.

## 14.1 변수의 생명주기

### 📝 지역 변수의 생명 주기

변수에게도 생명주기가 존재하는데, 프로그램이 종료되면 해당 프로그램이 점유하고 있던 공간을 비우면서 변수들이 사라진다.

만일 프로그램이 종료될 때 변수가 메모리에서 없어지지 않으면, 메모리가 금방 부족해져 계속 재부팅을 해야만 할 것이다.

그 중에서 전역 공간에서 선언한 경우에는 생명주기가 프로그램 종료까지 계속되어 메모리를 점유하고 있게 된다.

하지만, 함수나 코드 블록 내에서 선언된 지역변수의 경우 해당 코드 블록의 실행이 끝나면 소멸한다.

    ```javascript
    var a = "global";

    function foo() {
    var x = "local";
    console.log(x);
    return x;
    }

    foo();
    console.log(a); // "global"
    console.log(x); // ReferenceError: x is not defined
    ```

위 예시를 보면, 지역 변수의 생명주기를 단박에 이해할 수 있을 것이다.  
함수가 종료되니 지역변수 `x` 또한 사라져, 더 이상 존재하지 않기 때문이다.

하지만, 함수와 함수 내부 지역변수의 생명주기가 완전히 동일하다고는 말하기 어렵다.
자바스크립트의 가비지 컬렉터에 의해 회수가 되어야 완전히 소멸한다고 말할 수 있는데,
외부에서 해당 스코프나 변수를 참조하고 있을 경우, 여전히 메모리에 존재하는 상황이 되기 때문이다.

    ✨ 이 상황은 추후에 클로저를 배울 때 다뤄보자.

전역 변수는 프로그램이 종료 되기 전까지 메모리 공간을 차지하고 있기 때문에  
반드시 필요하지 않다면 지역변수로 사용하는 게 메모리 관점에서는 효율적이다.

아래 예시는, 지역 변수의 호이스팅이다.

    ```javascript
    var x = "global";

    function foo() {
    console.log(x);
    var x = "local";
    }

    foo(); // undefined
    console.log(x); // "global"
    ```

함수 `foo()` 를 실행하니, 전역 변수 `x` 가 아닌 지역 변수 `x` 를 참조해 `undefined` 를 출력했다.

이처럼, 호이스팅은 변수나 함수의 선언부가 스코프의 최상단으로 끌어올려지는 현상을 말한다.

### 📝 전역 변수의 생명 주기

앞서 다뤘듯, 전역 변수는 프로그램 종료 시까지 계속해서 참조가 가능하다.  
다만, 브라우저 환경에서는 전역 공간이 `window` 객체이기 때문에 브라우저 환경에서는 `window` 의 생명주기와 일치한다고 말해야 옳다.

## 14.2 전역 변수의 문제점

1. 암묵적 결합

   - 전역 변수는 최상위 스코프에서 선언된 변수로, 모든 하위 스코프에서 참조 및 수정이 가능하다.  
     코드가 복잡해질 수록, 스코프 내부가 아니라 전역 공간의 변수만을 참조한다면 코드의 가독성이 떨어지고 의도치 않게 상태가 변경되는 문제가 생기기도 한다.

2. 긴 생명 주기

   - 전역 변수는 전역 객체 종료시 까지 메모리 공간을 차지하고 있다.
     물론 `let` 이나 `const` 를 사용하면 중복 선언을 막을 수는 있지만 `let` 은 변경이 가능하기도 하며, 이름이 중복되지 않게 전역 변수를 다 외워둬야한다.

3. 스코프 체인 상에서 종점에 존재

   - 스코프 체인의 탐색은, 해당 코드가 실행된 스코프(하위)에서 전역 공간을 향해 올라가는 구조를 취한다. 따라서, 전역 공간에서만 변수를 사용한다면 불필요하게 전역 공간까지 찾아가야만 하는 문제가 있다.

4. 네임스페이스 오염
   - 프로젝트가 거대해지면, 모듈화 등 다른 파일을 통해 분리해서 코드를 작성하게 된다.
     이때, 전역 공간에서 선언한 식별자가 같다면 충돌이 생긴다.

## 14.3 전역 변수의 사용을 억제하는 방법

앞서, 전역 변수의 문제점에 대해서 다뤘던 것 처럼 가능하면 최대한 변수의 스코프를 좁히는게 좋다.

다음은 변수의 스코프를 좁힐 수 있는 여러 방법이다.

1. 즉시 실행 함수

   ```javascript
   (function () {
     var foo = 10;
   })();

   console.log(foo); // ReferenceError: foo is not defined
   ```

   위 처럼, 즉시 실행함수를 사용하면 단 한 번만 호출하기 때문에 전역 변수를 만들지 않게된다.

2. 네임스페이스 객체

   ```javascript
   var MYAPP = {}; // 전역 네임스페이스 객체

   MYAPP.name = "LEE";

   console.log(MYAPP.name); // "LEE"
   ```

   하지만, 결국 네임스페이스 객체가 전역 공간에서 선언되기에 별 도움은 안된다.

3. 모듈 패턴

   ```javascript
   var Counter = function () {
     // private 변수
     var num = 0;

     return {
       increase() {
         return ++num;
       },
       decrease() {
         return --num;
       },
     };
   };
   ```

   위 방법은 클래스를 모방해, 즉시실행함수를 만들어 하나의 모듈을 만든 것이다.
   하지만, 이 또한 클로저를 알아야 올바르게 사용이 가능하다.

4. ES6 모듈

   ```html
   <script type="module" src="lib.jsx"></script>
   ```

   ES6 에서 추가된 ES6 모듈은 전역 변수 사용을 아예 막을 수 있는 방법 중 하나다.
   각 모듈이 개별적인 스코프를 갖기 때문이다. 위 처럼, 파일을 import 해 쓰면 사용이 가능한데 babel 이나 webpack 같은 모듈 번들러가 필요하다.
