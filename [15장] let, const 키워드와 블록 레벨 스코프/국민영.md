# [15장] let, const 키워드와 블록 스코프

## ✅ var 키워드로 선언한 변수의 문제점

### 📍 변수 중복 선언 허용

에러를 발생시키지 않고 재할당이 되어버리기에 의도치 않게 값을 변경 시키는 문제가 발생할 수 있다.

### 📍 함수 레벨 스포크

var 키워드는 오로지 함수 코드블록만을 지역 스코프로 인정해서 외부에서 선언한 변수는 블록내에서 선언해도 모두 전역 변수가 되버린다

```jsx
// 예제 1
var x = 1;

if (true) {
  var x = 10;
}

console.log(x); // 10

// 예제 2
// for문의 변수 선언문애세 사용한 변수까지 전역 변수가 되버린다
var i = 10;

for (var i = 0; i < 5; i++) {
  console.log(i); // 0 1 2 3 4
}

console.log(i); // 5
```

### 📍 변수 호이스팅

var 키워드로 선언한 변수는 변수 선언문 이전에 참조 할 수 있다.
변수 선언문 이전에 변수를 참조하는 것은 변수 호이스팅에 의해 에러를 발생 시키지 않지만,
프로그램 흐름상 맞지 않고 가독성을 떨어 뜨리고 오류를 발생시킬 여지를 남긴다

```jsx
// 이 시점에는 변수 호이스팅에 의해 이미 foo변수가 선언되었다(1. 선언단계)
// 변수 foo는 undefined로 초기화된다(2. 초기화 단계)

console.log(foo); // undefined

// 변수에 값을 할당(3. 할당 단계)
foo = 123;

console.log(foo); // 123

// 변수 선언은 런타임 이전에 자바스크립트 엔진에 의해 암묵적 실행
var foo;
```

## ✅ let 키워드

### 📍 변수 중복 선언 금지

이름이 같은 변수를 중복 선언하면 문법 에러가 발생

### 📍 블록 레벨 스코프

모든 코드 블록(함수, if문, for문, while문, try/catch문 등)을 지역 스코프로 인정하는 **블록 레벨 스코프**를 따름

```jsx
let foo = 1; // 전역 변수

{
  let foo = 2;
  let bar = 3;
}

console.log(foo); // 1
console.log(bar); // ReferenceError: bar is not defined
```

### 📍 변수 호이스팅

변수 호이스팅이 발생하지 않는 것처럼 동작

```jsx
console.log(foo); // ReferenceError: foo is not defined
let foo;
```

- let 키워드로 선언한 변수를 변수 선언문 이전에 참조하면 참조 에러가 발생

- let 키워드로 선언한 변수는 "선언 단계"와 "초기화 단계"가 분리되어 진행

- 런타임 이전에 자바스크립트 엔진에 의해 암묵적으로 선언 단계가 먼저 실행되지만 초기화 단계는 변수 선언문에 도달했을 때 실행

```jsx
// 런타임 이전에 선언 단계 실행. 아직 변수가 초기화 되지 않았다
// 초기화 이전의 일시적 사각지대에서는 변수를 참조할 수 없다
console.log(foo); // ReferenceError

let foo; // 변수 선언문에서 초기화 단계 실행
console.log(foo); // undefined

foo = 1; // 할당문에서 할당 단계가 실행
console.log(foo); // 1

// 이렇게 let 키워드는 변수 호이스팅이 발생하지 않는 것 같아 보이지만
// 그렇지 않다!! 그 예제를 보자~~
let foo = 1; // 전역 변수
{
  console.log(foo); // ReferenceError
  let foo = 2; // 지역 변수
}

// let 키워드로 선언한 변수의 경우 호이스팅이 발생하지 않는다면 위 예제는 전역 변수 foo값을 출력해야한다. 하지만 let키워드로 선언한 변수도 여전히 호이스팅이 발생하기에 참조 에러가 발생하는 것

// 모든 선언을 호이스팅하지만
// let, const, class를 사용한 선언문은 호이스팅이 발생하지 않는 것처럼 동작하는 것
```

### 📍 전역 객체와 let

- var 키워드로 선언한 전역 변수는 전역 객체 window의 프로퍼티
- let, const 키워드로 선언한 전역 변수는 전역 객체 window의 프로퍼티가 아니다

## ✅ const 키워드

상수(constant)를 선언하기 위해 사용
하지만 반드시 상수만을 위해 사용하지는 X
대부분의 특징이 let과 비슷하므로 let키워드와 다른점을 중심으로 비교

### 📍 선언과 초기화

**const 키워드로 선언한 변수는 반드시 선언과 동시에 초기화해야 한다**

- 그렇지 않으면 문법에러(SyntaxError) 발생

### 📍 재할당 금지

var, let과 달리 재할당이 금지된다
재할당 하려고 하면 TypeError

### 📍 상수

- const키워드로 선언한 변수에 원시 값을 할당한 경우 변수 값 변경 X
- 변수의 상대개념이 상수(재할당 금지된 변수)를 말하지만 상수도 값을 저장하기 위한 메모르 공간이 필요하므로 변수라고 할 수 있다.
- 변수는 언제든지 언제든지 재할당을 통해 벼수 값을 변경할 수 있지만 상수는 재할당인 금지이기에 **상수는 상태 유지와 가독성, 유지보수 편의를 위해 적극 사용해야 함**

```jsx
// const를 사용해 가독성과 유지보수성을 up시키는 코드로 바꿔보기 예제~!
// before 🐰
let preTaxPricer = 100; // 세전 가격

// 세후가경
// 0.1의 의미를 명확히 알기 어렵기 때문에 가독성이 좋지 못하다
let afterTaxPrice = preTaxPrice + PreTaxPrice * 0.1;

console.log(afterTaxPrice); // 110

// 1. 0.1의 의미를 파악하기 어렵다
// 2. 또 0.1은 쉽게 바뀌지 않을 값, 프로그램 전체에서 고정된 값 사용이 필요
// 3. 상수는 대문자로 선언해 상수임을 명확히 나타내고, 여러 단어로 이러워졌을땐 언더스코어(_)로 구분

// after🐰
const TAX_RATE = 0.1; // 세율의 의미하는 0.1을 변경할수 없는 상수로 선언~! 대문자로 상수임을 광고`!!

// 세전가격
let preTaxPrice = 100;

// 세후가격
let afterTaxPrice = preTaxPrice + preTaxPrice * TAX_RATE;

console.log(afterTaxPrice); // 110
```

### 📍 const 키워드와 객체

const로 선언된 원시 값은 변경할 수 없지만 객체가 할달된 경우 변경 가능한 값인 객체의 객체는 직졉 변경이 가능!

```jsx
const person = {
  name: "Lee",
};

// 객체는 변경 가능한 값. 따라서 재할달없이 변경 가능
person.name = "Kim";

console.log(person); // [name: 'Kim']
```

**const 키워드는 재할당을 금지할 뿐 "불변"을 의미하는 건 X**

- 새로운 값을 재할당 하는 것은 불가능
- 프로퍼티 동적 생성, 삭제, 프로퍼티 값의 변경을 통해 객체 변경은 가능
- 객체가 변경되더라도 변수에 할당된 참조 값이 변경되는 것은 아니기 때문

## ✅ var vs. let vs. const

일단 변수를 선언때는 그냥 const사용해라~!!
정말 정말 정말 재할당이 필요하면? 그때 let으로 변경해라.
생각보다 재할당을 하는 경우는 드물다~!!
