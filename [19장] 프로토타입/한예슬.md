# 19장 프로토타입

> - 자바스크립트는 `프로토타입 기반 언어`로, 모든 객체는 자신의 부모 역할을 하는 프로토타입 객체와 연결되어 있다.<br>
> - 프로토타입 객체는 생성자 함수에 의해 생성된 객체에 공유 프로퍼티를 제공하며, 프로토타입 체인을 통해 객체는 상위 프로토타입의 프로퍼티와 메서드를 사용할 수 있다. <br>
>   => 상속을 받을 수 있다.
> - 모든 객체의 최상위 프로토타입은 `Object.prototype` 이다.

## ✔️ 19.1 객체지향 프로그래밍

: 절차지향적인 관점에서 벗어나 `여러개의 독립적 단위`, <br>
즉 `객체의 집합`으로 프로그램을 표현하려는 프로그래밍 패러다임을 말한다.<br>

- 객체지향 프로그래밍은 실세계의 실체(사물이나 개념)를 인식하는 철학적 사고를 프로그래밍에 접목하려는 시도에서 시작한다.<br>
  -> 실체는 특징이나 성질을 나타내는 `속성`(attribute / property)을 가지고 있고, 이를 통해 실체를 인식하거나 구별할 수 있다.<br>
  -> 다양한 속성 중에서 프로그램에 필요한 속성만 간추려내어 표현하는 것을 `추상화` 라고한다.<br>

```jsx
// 사람에게는 다양한 속성이 있으나 우리가 구현하려는 프로그램에서는
// 사람의 "이름"과 "주소"라는 속성에만 관심이 있다고 가정하면
// 필요한 속성만 아래처럼 사용할 수 있다.
const person = {
  name: "lee",
  address: "Seoul",
};
```

- `속성을 통해 여러개의 값을 하나의 단위로 구성한 복합적인 자료구조`를 `객체`라고 한다.
- 객체 지향 프로그래밍은 독립적인 객체의 집합으로 프로그램을 표현하려는 프로그래밍 패러다임이다.

### 💡객체 지향 프로그래밍은 객체의 `상태(state)를 나타내는 데이터`와 `상태데이터를 조작할 수 있는 동작(be-havior)`을 하나의 논리적인 단위로 `묶어` 생각한다.

-> 객체는 상태데이터와 동작을 하나의 논리적인 단위로 묶은 복합적인 자료구조이다.

### 💡객체의 상태데이터 : 프로퍼티 (property) / 동작 : 메서드 (method)

> 원 객체에서 반지름은 원의 상태를 나타내는 데이터 이며<br>
> 원의 지름, 둘레 넓이를 구하는 것은 동작이다.

---

## ✔️ 19.2 상속과 프로토타입

- 상속(inheritance) 이란, 어떤 객체의 프로퍼티 또는 메서드를 다른 객체가 상속받아 그대로 사용할 수 있는 것.
- 자바스크립트는 `프로토타입을 기반`으로 상속을 구현하여 `불필요한 중복을 제거`한다.
- 중복을 제거하는 방법은 `기존의 코드를 재사용` 하는 것이다.<br>
  -> <u>상태를 나타내는 인스턴스만 개별적으로 소유하고 내용이 동일한 메서드는
  상속을 통해 공유하여 사용.</u>

```jsx
function Circle(radius){
  this.radius = radius;
}

Circle.prototype.getArea = function () {
  //Math.PI는 원주율을 나타내는 상수다.
    return Math.PI * this.radius ** 2;
  };
}

const circle1 = new Circle(1);
const circle2 = new Circle(2);

console.log(circle1.getArea === circle2.getArea); // true
```

---

## ✔️ 19.3 프로토타입 객체

https://www.nextree.co.kr/p7323/

### : <u>어떤 객체의 상위(부모) 객체의 역할을 하는 객체 </u>로서 다른객체에 공유프로퍼티(메서드 포함)를 제공한다.

### -> 객체지향 프로그래밍의 근간을 이루는 `객체간 상속을 구현하기 위해 사용`된다.

- 다른 객체에 공유 프로퍼티(메서드 포함)를 제공한다.
- 상속받은 하위(자식) 객체는 상위 객체의 프로퍼티를 자신의 객체처럼 자유롭게 사용할 수 있다.

### 💡 **proto** 접근자 프로퍼티
<img src="https://github.com/hyeonseok98/js-deep-dive-study/assets/166012944/84a10dd3-7de5-4764-8b8b-8450c9eeb901" width="700" height="500">

- 모든 객체는 `__proto__`접근자 프로퍼티를 통해 자신의 프로토타입, 즉 `[[Prototype]] 내부 슬롯`에 간접적으로 접근할 수 있다.
- 상속을 통해 사용된다.<br>
  -> **proto** 접근자 프로퍼티는 객체가 직접 소유하는 프로퍼티가 아니라 Object.prototype 의 프로퍼티다.<br>
  -> 모든 객체는 상속을 통해 Object.prototype.\_ _proto_ \_ 접근자 프로퍼티를 사용할 수 있다.

- **proto** 접근자 프로퍼티를 통해 프로토타입에 접근하는 이유<br>
  : 상호 참조에 의해 프로토타입 체인이 생성되는 것을 방지하기 위함이다.

- 프로토타입 체인은 `단방향 링크드 리스트`로 구현되어야 한다.<br>
  -> 즉, 프로퍼티 검색 방향이 한쪽 방향으로만 흘러가야한다.
- 서로가 자신의 프로토타입이 되는 비정상적인 프로토타입 체인, 다시말해 `순환참조` 하는 프로토타입 체인이 만들어지면 `프로토타입 체인 종점이 존재하지 않기때문에` 프로퍼티를 검색할때 `무한루프`에 빠지게 된다.
- **proto** 접근자 프로퍼티 대신 프로토타입의 참조를 취득하고 싶은 경우에는 Object.getPrototypeOf 메서드를 사용하고, 프로토타입을 교체하고 싶은 경우에는 Object.setPrototypeOf 메서드를 사용할 것을 권장한다.

### 💡 함수 객체의 prototype 프로퍼티

- 함수 객체만이 소유하는 prototype 프로퍼티는 생성자 함수가 생성할 인스턴스의 프로토타입을 가리킨다.

```jsx
// 함수객체는 prototype 프로퍼티를 소유한다.
(function () {}).hasOwnProperty("prototype"); // true
// 일반객체는 prototype 프로퍼티를 소유하지 않는다.
({}).hasOwnProperty("prototype"); // false
```

❗생성자 함수로서 호출할 수 없는 함수 (non-constructor)인 화살표함수와 메서드 축약표현으로 정의한 메서드는 prototype 프로퍼티를 소유하지 않으며 프로토타입도 생성하지않는다.

### 💡 프로토타입의 constructor 프로퍼티와 생성자함수

- 모든 프로토타입은 constructor 프로퍼티를 갖는다.
- 이 프로퍼티는 prototype 프로퍼티로 자신을 참조하고 있는 생성자함수를 가리킨다.
- 이 연결은 생성자 함수가 생성될때, 즉 함수객체가 생성될 떄 이뤄진다.<br>
  ex)

```jsx
// 생성자함수
function Person(name) {
  this.name = name;
}

const me = new Person("Lee");
//me 객체의 생성자 함수는 Person 이다.
console.log(me.constructor === Person); // true
```

---

## ✔️ 19.4 리터럴 표기법에 의해 생성된 객체의 생성자 함수와 프로토타입

- 생성자 함수에 의해 생성된 인스턴스는 프로토타입의 constructor 프로퍼티에 의해 생성자 함수와 연결된다.
- 리터럴 표기법에 의한 객체 생성 방식과 같이 명시적으로 new 연산자와 함께 생성자 함수를 호출하여 인스턴스를 생성하지 않는 객체 생성 방식도 있다.
- 리터럴 표기법에 의해 생성된 객체도 프로토타입이 존재하지만, constructor 프로퍼티가 가리키는 생성자 함수가 반드시 객체를 생성한 생성자 함수라고 단정할 수는 없다.

<br>

```jsx
// obj 객체는 Object 생성자 함수로 생성한 객체가 아니라 객체 리터럴로 생성했다.
const obj = {};

// obj 객체의 생성자 함수는 Object 생성자 함수다.
console.log(obj.constructor === Object); // true
```
<img src="https://github.com/hyeonseok98/js-deep-dive-study/assets/166012944/3795d55c-a678-44a1-9758-b3732641db2e" width="700" height="500">

-> 위 예제는 객체 리터럴에 의해 생성된 객체이지만,<br>
obj 객체가 Objcet 생성자 함수와 constructor 프로퍼티로 연결되어있다.<br>

### ❓객체 리터럴에 의해 생성된 객체는 사실 Object 생성자 함수로 생성되는 건 아닐까?

-> Object 생성자 함수에 인수를 전달하지 않거나 undefined / null 을 인수로 전달하면서 호출하면, <br> 내부적으로는 `추상연산`(OrdinaryObjectCreate) 를 호출하여 `Object.prototype 을 프로토타입으로 갖는 빈 객체를 생성`한다.<br>

### ❗Object 생성자 함수 호출과 객체 리터럴의 평가는 추상연산을 호출하여 빈객체를 생성하는 점에서 동일하나, new.target 의 확인이나 프로퍼티를 추가하는 처리 등 세부 내용은 다르다.<br>

-> 객체 리터럴에 의해 생성된 객체는 Object 생성자 함수가 생성한 객체가 아니다.

<br>

- 리터럴 표기법에 의해 생성된 객체도 `상속`을 위해 `프로토타입`이 필요하다.
- prototype - constructor 프로퍼티에 의해 연결되어 있기 때문에 프로토타입은 생성자 함수와 더불어 생성된다. -> 리터럴 표기법에 의해 생성된 객체도 가상적인 생성자 함수를 갖는다.

### 💡 프로토타입과 생성자함수는 단독으로 존재할 수 없고, 언제나 쌍(pair)으로 존재한다.

- 리터럴 표기법에 의해 생성된 객체는 생성자 함수에 의해 생성된 객체는 아니지만, 본질적인 면에서 큰 차이는 없다.
- 프로토타입의 constructor 프로퍼티를 통해 연결되어 있는 생성자 함수를 리터럴 표기법으로 생성한 생성자 함수로 생각해도 무리는 없다.

| 리터럴 표기법      | 생성자 함수 | 프로토타입         |
| ------------------ | ----------- | ------------------ |
| 객체리터럴         | Object      | Object.prototype   |
| 함수 리터럴        | Function    | Function.prototype |
| 배열 리터럴        | Array       | Array.prototype    |
| 정규 표현식 리터럴 | RegExp      | RegExp.prototype   |

<br>

---

## ✔️ 19.5 프로토타입의 생성 시점

- 프로토타입은 생성자 함수가 생성되는 시점에 더불어 생성된다.<br>
  (프로토타입과 생성자함수는 언제나 쌍으로 존재)
- 생성자 함수
  - 사용자 정의 생성자 함수
  - 빌트인 생성자 함수

### 💡사용자 정의 생성자 함수와 프로토타입 생성 시점

#### -> `함수 정의가 평가`되어 함수 객체를 생성하는 시점에 프로토타입도 더불어 생성된다.

```jsx
// 함수 정의(constructor)가 평가되어 함수 객체를 생성하는 시점에 프로토타입도 더불어 생성된다.
console.log(Person.prototype); // {constructor: f}

// 생성자 함수
function Person(name) {
  this.name = name;
}
```

- 생성자 함수로서 호출할 수 없는 함수, non-constructor 는 프로토타입이 생성되지 않는다.

```jsx
// 화살표 함수는 non-constructor 이다.
const Person = (name) => {
  this.name = name;
};

// non-constructor 는 프로토타입이 생성되지 않는다.
console.log(Person.prototype); // undefined
```

- 호이스팅에 의해 함수 선언문으로 정의된 Person 생성자 함수는 어떤 코드보다 먼저 평가되어 함수 객체가 된다.
- 이때 프로토타입도 더불어 생성된다.
- 생성된 프로토타입은 Person 생성자 함수 prototype 프로퍼티에 바인딩 된다.

```jsx
console.log(Person.prototype);

function Person(name) {
  this.name = name;
}
```

- 생성된 프로토타입은 오직 constructor 프로퍼티만을 갖는 객체다.
- 프로토타입도 객체고 모든 객체는 프로토타입을 가지므로 `프로토타입도 자신의 프로토타입`을 갖는다.
- 생성된 프로토타입의 프로토타입은 `Object.prototype` 이다.

<br>

### 💡빌트인 생성자 함수와 프로토타입 생성 시점

- 빌트인 생성자 함수도 일반함수와 마찬가지로 `빌트인 생성자 함수가 생성되는 시점`에
  `프로토타입이 생성`된다.
- 모든 빌트인 생성자함수는 `전역 객체가 생성되는 시점`에 생성된다.
- 생성된 프로토타입은 `빌트인 생성자 함수의 prototype 프로퍼티에 바인딩`된다.

> ### 📌 전역객체
>
> 전역 객체는 코드가 실행되기 이전에 자바스크립트 엔진에 의해 생성되는 특수한 객체다.<br>
> -> 브라우저 : window | Node.js : global 객체
> 표준 빌트인 객체들과 환경에 따른 호스트 객체(Web API 또는 Node.js),
> var 키워드로 선언한 전역 변수와 전역 함수를 프로퍼티로 갖는다.
> Math, Reflect, JSON을 제외한 표준 빌트인 객체는 모두 생성자 함수다.

=> 객체가 생성되기 이전에 생성자 함수와 프로토타입은 이미 객체화 되어 존재한다.<br>
=> 생성자 함수 / 리터럴 표기법으로 객체를 생성.<br>
=> 프로토타입은 생성된 객체의 [[Prototype]] 내부 슬롯에 할당된다.<br>
=> 생성된 객체는 프로토타입을 상속받는다.<br>

---

## ✔️ 19.6 객체 생성 방식과 프로토타입의 결정

- 객체의 생성 방법
  - 객체리터럴
  - Object 생성자 함수
  - 생성자 함수
  - Object.create 메서드
  - 클래스(ES6)

-> 세부 생성 방식에는 차이가 있으나 `추상연산 (OrdinaryObjectCreate)` 에 의해
생성된다는 공통점이 있다.

- 추상 연산(OrdinaryObjectCreat)은 필수적으로 자신이 생성할 객체의 프로토타입을 인수로 전달 받는다.
- 자신이 생성할 객체에 추가할 프로퍼티 목록을 옵션으로 전달할 수 있다.

-> 이 연산은 `빈 객체를 생성`한 후, 객체에 추가할 `프로퍼티 목록`이 `인수로 전달`된 경우 프로퍼티를 `객체에 추가`한다. <br>
-> 인수로 전달받은 프로토타입을 `자신이 생성한 객체의 [[Prototype]] 내부 슬롯에
할당`한 다음, `생성한 객체를 반환`한다.

❗프로토타입은 `추상 연산에 전달되는 인수에 의해 결정`된다.<br>
이 인수는 객체가 생성되는 시점에 객체 생성 방식에 의해 결정된다.

<br>

### 💡<u>객체 리터럴</u>에 의해 생성된 객체의 프로토타입

- 자바스크립트 엔진은 객체 리터럴을 평가하여 객체를 생성할때 추상 연산 OrdinaryObjectCreate를 호출한다.
- 이때 전달되는 프로토타입은 Object.prototype 이다.<br>
  => 즉, `객체 리터럴`에 의해 생성되는 프로토타입은 `Object.prototype`이다.

```jsx
const obj = { x: 1 };
```

객체 리터럴이 평가되면 추상 연산에 의해 다음과 같이 Object 생성자 함수와 Object.prototype과 생성된 객체 사이에 `연결`이 만들어진다.<br>
이처럼 객체 리터럴에 의해 생성된 obj 객체는 `Object.prototype`을 프로토타입으로 갖게되며, 상속 받는다.<br>
그렇기 때문에 Object.prototype의 메서드들을 자신의 것처럼 사용이 가능하다.

<br>

### 💡<u>Object 생성자 함수</u>에 의해 생성된 객체의 프로토타입

- Object 생성자 함수를 `인수 없이 호출하면 빈 객체가 생성`된다.
- Object 생성자 함수를 호출하면 객체 리터럴과 마찬가지로 추상 연산이 호출된다.
- 이때 전달되는 프로토타입은 `Object.prototype` 이다.

- ❗`객체 리터럴`과 `Object 생성자 함수`에 의한 객체 생성 방식의 차이는
  `프로퍼티를 추가하는 방식`에 있다.
  - 객체 리터럴 방식 - 객체 리터럴 `내부`에 프로퍼티를 추가
  - Object 생성자 함수 방식 - `일반 빈 객체를 생성`한 이후에 프로퍼티를 추가

<br>

### 💡<u>생성자 함수</u>에 의해 생성된 객체의 프로토타입

- `new 연산자`와 함께 생성자 함수를 호출하여 인스턴스를 생성하면
  다른 객체 생성 방식과 마찬가지로 추상 연산이 호출된다.
- 이때 추상 연산에 전달되는 프로토타입은 `생성자 함수의 prototype 프로퍼티에
바인딩되어있는 객체`다.<br>
  => 생성자 함수에 의해 생성되는 객체의 프로토타입은 생성자 함수의
  prototype 프로퍼티에 바인딩 되어 있는 객체다.

- 프로토타입도 객체이기 때문에 일반객체처럼 프로퍼티를 추가/삭제할 수 있다.

- 추가/삭제된 프로퍼티는 프로토타입 체인에 즉각 반영된다.

```jsx
function Person(name) {
  this.name = name;
}

// 프로토타입 메서드
Person.prototype.sayHello = function () {
  cosnole.log("Hi! My name is ${this.name}");
}

const me = new Person("lee");
const you = new Person('kim);

me.sayHello(); // Hi! My name is lee
you.sayHello(); // Hi! My name is Kim
```

---

## ✔️ 19.7 프로토타입 체인

- 자바스크립트는 객체의 프로퍼티(메서드 포함)에 접근하려고 할때,<br>
  해당 객체에 접근하려는 프로퍼티가 없다면 `[[Prototype]] 내부 슬롯의 참조를 따라`
  자신의 부모 역할을 하는 `프로토타입의 프로퍼티를 순차적으로 검색`한다.<br>
  => 이를 `프로토타입 체인`이라한다.<br>
  => 프로토타입 체인은 자바스크립트가 `객체지향 프로그래밍의 상속을 구현하는
메커니즘`이다.

- 프로토타입 체인의 `최상위 객체는 항상 Object.prototype` 이며
  이를 `프로토타입 체인의 종점(end of prototype chain)`이라 한다.<br>
  => 따라서 모든 객체는 Object.prototype을 상속받는다.

- Object.prototype의 프로토타입은 null 이다.<br>
  => Ojbect.prototype에서도 프로퍼티를 발견하지 못한 경우 에러가 아닌 `undefined`를 반환한다.

<br>

### 💡스코프 체인과 프로토타입 체인

- <스코프 체인>은 <식별자를 탐색>하기 위한 메커니즘이고
- <프로토타입 체인>은 <프로퍼티를 탐색>하기 위한 메커니즘이다.

<br>

아래 예제는 먼저 스코프 체인에서 me 식별자를 검색하고,
me 객체의 프로토타입 체인에서 hasOwnProperty를 검색한다.

```jsx
me.hasOwnProperty("name");
```

=> 이처럼 스코프체인과 프로토타입 체인은 서로 협력하여 식별자와 프로퍼티를 검색한다.
