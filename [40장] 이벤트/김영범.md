# [40장] 이벤트

## 40.1 이벤트 드리븐 프로그래밍

브라우저는 마우스 클릭, 키보드 입력, 마우스 이동 등이 일어나면 감지해 특정한 타입의 이벤트를 발생시킨다.

이런 이벤트가 발생했을 때, 별도로 함수를 호출해 동작을 정의할 수 있다.
이 함수를 이벤트 핸들러(Event Handler)라고 부르고, 이벤트 핸들러의 호출을 위임하는 것을 **이벤트 핸들러 등록**이라 부른다.

브라우저가 감지하는 이벤트는 어떤 것이 있는지 알아보자.

## 40.2 이벤트 타입

### 📝 마우스 이벤트

| 이벤트     | 이벤트 발생 시점                                             |
| ---------- | ------------------------------------------------------------ |
| click      | 마우스 버튼을 클릭했을 때                                    |
| dbclick    | 마우스 버튼을 더블 클릭했을 때                               |
| mousedown  | 마우스 버튼을 눌렀을 때                                      |
| mouseup    | 누르고 있던 마우스 버튼을 놓았을 때                          |
| mousemove  | 마우스 커서를 움직였을 때                                    |
| mouseenter | 마우스 커서를 HTML 요소 안으로 이동했을 때(버블링 되지 않음) |
| mouseover  | 마우스 커서를 HTML 요소 안으로 이동했을 때(버블링 됨)        |
| mouseleave | 마우스 커서를 HTML 요소 밖으로 이동했을 때(버블링 되지 않음) |
| mouseout   | 마우스 커서를 HTML 요소 밖으로 이동했을 때(버블링 됨)        |

### 📝 키보드 이벤트

| 이벤트 타입 | 이벤트 발생 시점                                                                                                       |
| ----------- | ---------------------------------------------------------------------------------------------------------------------- |
| keydown     | 키보드의 모든 키 입력시 연속적 발생(문자, 숫자, 특문, enter 를 제외한 경우는 한 번만 발생)                             |
| keypress    | 문자 키를 눌렀을 때 연속적으로 발생(deprecated)                                                                        |
| keyup       | 누르고 있던 키를 놓았을 때 한 번만 발생(control, option, shift, tab, delete, enter, 방향키, 문자, 특문 키를 놓았을 때) |

### 📝 포커스 이벤트

| 이벤트 타입 | 이벤트 발생 시점                             |
| ----------- | -------------------------------------------- |
| focus       | HTML 요소가 포커스를 받았을 때(버블링 안 됨) |
| blur        | HTML 요소가 포커스를 잃었을 때(버블링 안 됨) |
| focusin     | HTML 요소가 포커스를 받았을 때(버블링 됨)    |
| focusout    | HTML 요소가 포커스를 잃었을 때(버블링 됨)    |

❗focusin, focusout 이벤트는 addEventListener 메서드로 추가해야 크롬과 사파리에서 올바르게 동작한다. 이벤트 핸들러 프로퍼티 방식(onfocusin, onfocusout 등)으로 추가하면 동작하지 않는다.

### 📝 폼 이벤트

| 이벤트 타입 | 이벤트 발생 시점                                                                                                                                   |
| ----------- | -------------------------------------------------------------------------------------------------------------------------------------------------- |
| submit      | form 요소 내의 input, select 입력 필드에서 엔터 키를 눌렀을 때 또는 form 요소 내의 submit 버튼(`<button`, `<input type="submit">`>) 을 클릭했을 때 |
| reset       | form 요소 내의 reset 버튼을 클릭했을 때(잘 사용하지 않음)                                                                                          |

### 📝 값 변경 이벤트

| 이벤트 타입      | 이벤트 발생 시점                                                                                                          |
| ---------------- | ------------------------------------------------------------------------------------------------------------------------- |
| input            | input, select, textarea 요소의 값이 입력되었을 때                                                                         |
| change           | input, select, textarea 요소의 값이 변경되었을 때                                                                         |
| readystatechange | HTML 문서의 로드와 파싱 상태를 나타내는 document.readyState 프로퍼티 값('loading', 'interactive', 'complete')이 변경될 때 |

### 📝 DOM 뮤테이션 이벤트

| 이벤트 타입      | 이벤트 발생 시점                                   |
| ---------------- | -------------------------------------------------- |
| DOMContentLoaded | HTML 문서의 로드와 파싱이 완료돼 DOM 생성이 완료시 |

### 📝 뷰 이벤트

| 이벤트 타입 | 이벤트 발생 시점                                                |
| ----------- | --------------------------------------------------------------- |
| resize      | 브라우저 윈도우(window)의 크기를 리사이즈할 때 연속적으로 발생  |
| scroll      | 웹페이지(document) 또는 HTML 요소를 스크롤할 때 연속적으로 발생 |

### 📝 리소스 이벤트

| 이벤트 타입 | 이벤트 발생 시점                                                                   |
| ----------- | ---------------------------------------------------------------------------------- |
| load        | DOMContentLoaded 이벤트 발생 후, 모든 리소스(이미지, 폰트 등)의 로딩이 완료됐을 때 |
| unload      | 리소스가 언로드될 때(주로 새로운 웹 페이지를 요청한 경우)                          |
| abort       | 리소스 로딩이 중단됐을 때                                                          |
| error       | 리소스 로딩이 실패했을 때                                                          |

## 40.3 이벤트 핸들러 등록

이벤트 핸들러 등록 방법에 대해 알아보자.

### 📝 이벤트 핸들러 어트리뷰트 방식

아래와 같이 사용하면 된다.

```html
<!DOCTYPE html>
<html>
  <body>
    <button onclick="sayHi('Lee')">Click me!</button>
    <script>
      function sayHi(name) {
        console.log(`Hi! ${name}. `);
      }
    </script>
  </body>
</html>
```

이렇게 어트리뷰트 값으로 함수 호출문을 할당하는 방식이다.

vanila JS 와 함께 사용하는 경우, 이런 방식은 권장하지 않는다.
그러나 현재 많이 이용하는 컴포넌트 기반 프레임워크 / 라이브러리에서는 이 방식을 다시 사용하게 된다.

### 📝 이벤트 핸들러 프로퍼티 방식

DOM 노드 객체는 이벤트 핸들러에 대한 프로퍼티 또한 가지고 있다.
이 프로퍼티에 함수를 할당하면 이벤트 핸들러 등록이 가능하다.

```html
<!DOCTYPE html>
<html>
  <body>
    <button>Click me!</button>
    <script>
      const $button = document.querySelector("button");

      // 이벤트 핸들러 프로퍼티에 이벤트 핸들러를 바인딩
      $button.onclick = function () {
        console.log("button click 1");
      };

      // 이벤트 핸들러 프로퍼티에 다른 이벤트 핸들러를 재할당, 첫 번째로 등록한 함수는 실행되지 않음
      $button.onclick = function () {
        console.log("button click 2");
      };
    </script>
  </body>
</html>
```

### 📝 addEventListener 메서드 방식

`addEventListener` 메서드를 사용해 이벤트 핸들러를 등록할 수 있다.

![addEventListener 메서드](./img/addEventListener.png)

첫 번째 매개변수는 이벤트 종류가 온다.
두 번째 매개변수는 이벤트 핸들러를 전달받는다.
마지막 세 번째 매개변수는 생략 가능하며, 이벤트 캡처링 또는 이벤트 버블링을 사용할 것인지 선택할 수 있다. 기본값은 버블링이다.

```html
<!DOCTYPE html>
<html>
  <body>
    <button>Click me!</button>
    <script>
      const $button = document.querySelector("button");

      // 이벤트 핸들러 프로퍼티에 이벤트 핸들러를 바인딩
      $button.onclick = function () {
        console.log("button click 1");
      };

      $button.addEventListener("click", function () {
        console.log("button click 2");
      });
    </script>
  </body>
</html>
```

위 예시를 보면, 이벤트 핸들러 프로퍼티에 바인딩한 이벤트 핸들러와 `addEventListener()` 메서드로 추가한 것 모두 함께 동작한다.

`addEventListener()` 메서드는 하나 이상의 이벤트 핸들러를 등록할 수 있다.

```html
<!DOCTYPE html>
<html>
  <body>
    <button>Click me!</button>
    <script>
      const $button = document.querySelector("button");

      // 이벤트 핸들러 프로퍼티에 이벤트 핸들러를 바인딩
      $button.addEventListener("click", function () {
        console.log("button click 1");
      });
      $button.addEventListener("click", function () {
        console.log("button click 2");
      });
    </script>
  </body>
</html>
```

아래와 같이 동일한 참조를 가진 함수(이벤트 핸들러)를 등록할 경우 하나만 등록이 된다.

```html
<!DOCTYPE html>
<html>
  <body>
    <button>Click me!</button>
    <script>
      const $button = document.querySelector("button");

      const handleClick = function () {
        console.log("button click 1");
      };

      // 이벤트 핸들러 프로퍼티에 이벤트 핸들러를 바인딩
      $button.addEventListener("click", handleClick);
      $button.addEventListener("click", handleClick);
    </script>
  </body>
</html>
```

## 40.4 이벤트 핸들러 제거

`removeEventListener` 메서드를 사용하면 등록된 이벤트 핸들러를 제거할 수 있다.

이때, 메서드에 전달하는 인수는 `addEventListener` 메서드와 동일하다.

```html
<!DOCTYPE html>
<html>
  <body>
    <button>Click me!</button>
    <script>
      const $button = document.querySelector("button");

      const handleClick = () => {
        console.log("button click");
      };

      // 이벤트 핸들러 프로퍼티에 이벤트 핸들러를 바인딩
      $button.addEventListener("click", handleClick);
      $button.removeEventListener("click", handleClick, ture); // 제거 실패
      $button.removeEventListener("click", handleClick); // 제거 성공
    </script>
  </body>
</html>
```

위 예시를 보면, `addEventListener` 메서드로 등록할 때 사용한 인수를 동일하게 사용하지 않을 경우 제거에 실패하는 상황이다.

그런데, 무명 함수를 이벤트 핸들러로 등록한 경우 제거할 수가 없다.

```html
<button>Click me!</button>
<script>
  const $button = document.querySelector("button");

  $button.addEventListener("click", function () {
    console.log("button click 1");
  });

  $button.removeEventListener("click", function () {
    console.log("button click 1");
  });
</script>
```

이렇게 사용하더라도, 두 이벤트 핸들러의 참조가 저장되지 않기 때문에 그렇다.

또한 이벤트 핸들러 프로퍼티 방식으로 등록한 이벤트 핸들러는 제거가 불가능하다.

```javascript
const $button = document.querySelector("button");

const handleClick = function () {
  console.log("button click 1");
};

// 이벤트 핸들러 프로퍼티에 이벤트 핸들러를 바인딩
$button.onclick = handleClick;

// 제거 불가능
$button.removeEventListener("click", handleClick);

$button.onclick = null;
```
